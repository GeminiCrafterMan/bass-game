00000000                            ; ===========================================================================
00000000                            ; SWN-001 On The Fucking Sega Mega Drive
00000000                            ; TODO: better name
00000000                            ; ===========================================================================
00000000                            
00000000                            		include	"_Includes/Error Handler/Debugger.asm"
00000000                            
00000000                            ; ===============================================================
00000000                            ; ---------------------------------------------------------------
00000000                            ; Error handling and debugging modules
00000000                            ; 2016-2017, Vladikcomper
00000000                            ; ---------------------------------------------------------------
00000000                            ; Debugging macros definitions file
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            
00000000                            ; ===============================================================
00000000                            ; ---------------------------------------------------------------
00000000                            ; Constants
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            ; ----------------------------
00000000                            ; Arguments formatting flags
00000000                            ; ----------------------------
00000000                            
00000000                            ; General arguments format flags
00000000 =00000080                  hex		equ		$80				; flag to display as hexadecimal number
00000000 =00000090                  dec		equ		$90				; flag to display as decimal number
00000000 =000000A0                  bin		equ		$A0				; flag to display as binary number
00000000 =000000B0                  sym		equ		$B0				; flag to display as symbol (treat as offset, decode into symbol +displacement, if present)
00000000 =000000C0                  symdisp	equ		$C0				; flag to display as symbol's displacement alone (DO NOT USE, unless complex formatting is required, see notes below)
00000000 =000000D0                  str		equ		$D0				; flag to display as string (treat as offset, insert string from that offset)
00000000                            
00000000                            ; NOTES:
00000000                            ;	* By default, the "sym" flag displays both symbol and displacement (e.g.: "Map_Sonic+$2E")
00000000                            ;		In case, you need a different formatting for the displacement part (different text color and such),
00000000                            ;		use "sym|split", so the displacement won't be displayed until symdisp is met
00000000                            ;	* The "symdisp" can only be used after the "sym|split" instance, which decodes offset, otherwise, it'll
00000000                            ;		display a garbage offset.
00000000                            ;	* No other argument format flags (hex, dec, bin, str) are allowed between "sym|split" and "symdisp",
00000000                            ;		otherwise, the "symdisp" results are undefined.
00000000                            ;	* When using "str" flag, the argument should point to string offset that will be inserted.
00000000                            ;		Arguments format flags CAN NOT be used in the string (as no arguments are meant to be here),
00000000                            ;		only console control flags (see below).
00000000                            
00000000                            
00000000                            ; Additional flags ...
00000000                            ; ... for number formatters (hex, dec, bin)
00000000 =00000008                  signed	equ		8				; treat number as signed (display + or - before the number depending on sign)
00000000                            
00000000                            ; ... for symbol formatter (sym)
00000000 =00000008                  split	equ		8				; DO NOT write displacement (if present), skip and wait for "symdisp" flag to write it later (optional)
00000000 =00000004                  forced	equ		4				; display "<unknown>" if symbol was not found, otherwise, plain offset is displayed by the displacement formatter
00000000                            
00000000                            ; ... for symbol displacement formatter (symdisp)
00000000 =00000008                  weak	equ		8				; DO NOT write plain offset if symbol is displayed as "<unknown>"
00000000                            
00000000                            ; Argument type flags:
00000000                            ; - DO NOT USE in formatted strings processed by macros, as these are included automatically
00000000                            ; - ONLY USE when writting down strings manually with DC.B
00000000 =00000000                  byte	equ		0
00000000 =00000001                  word	equ		1
00000000 =00000003                  long	equ		3
00000000                            
00000000                            ; -----------------------
00000000                            ; Console control flags
00000000                            ; -----------------------
00000000                            
00000000                            ; Plain control flags: no arguments following
00000000 =000000E0                  endl	equ		$E0				; "End of line": flag for line break
00000000 =000000E6                  cr		equ		$E6				; "Carriage return": jump to the beginning of the line
00000000 =000000E8                  pal0	equ		$E8				; use palette line #0
00000000 =000000EA                  pal1	equ		$EA				; use palette line #1
00000000 =000000EC                  pal2	equ		$EC				; use palette line #2
00000000 =000000EE                  pal3	equ		$EE				; use palette line #3
00000000                            
00000000                            ; Parametrized control flags: followed by 1-byte argument
00000000 =000000F0                  setw	equ		$F0				; set line width: number of characters before automatic line break
00000000 =000000F4                  setoff	equ		$F4				; set tile offset: lower byte of base pattern, which points to tile index of ASCII character 00
00000000 =000000F8                  setpat	equ		$F8				; set tile pattern: high byte of base pattern, which determines palette flags and $100-tile section id
00000000 =000000FA                  setx	equ		$FA				; set x-position
00000000                            
00000000                            
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            ; Macros
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            RaiseError &
00000000                            
00000000                            	pea		*(pc)
00000000                            	move.w	sr, -(sp)
00000000                            	__FSTRING_GenerateArgumentsCode \string
00000000                            	jsr		ErrorHandler
00000000                            	__FSTRING_GenerateDecodedString \string
00000000                            	if strlen("\console_program")			; if console program offset is specified ...
00000000                            		dc.b	\opts+_eh_enter_console|(((*&1)^1)*_eh_align_offset)	; add flag "_eh_align_offset" if the next byte is at odd offset ...
00000000                            		even															; ... to tell Error handler to skip this byte, so it'll jump to ...
00000000                            		jmp		\console_program										; ... an aligned "jmp" instruction that calls console program itself
00000000                            	else
00000000                            		dc.b	\opts+0						; otherwise, just specify \opts for error handler, +0 will generate dc.b 0 ...
00000000                            		even								; ... in case \opts argument is empty or skipped
00000000                            	endc
00000000                            	even
00000000                            
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            Console &
00000000                            
00000000                            	if strcmp("\0","write")|strcmp("\0","writeline")
00000000                            		move.w	sr, -(sp)
00000000                            		__FSTRING_GenerateArgumentsCode \1
00000000                            		movem.l	a0-a2/d7, -(sp)
00000000                            		if (__sp>0)
00000000                            			lea		4*4(sp), a2
00000000                            		endc
00000000                            		lea		@str\@(pc), a1
00000000                            		jsr		ErrorHandler.__global__console_\0\_formatted
00000000                            		movem.l	(sp)+, a0-a2/d7
00000000                            		if (__sp>8)
00000000                            			lea		__sp(sp), sp
00000000                            		elseif (__sp>0)
00000000                            			addq.w	#__sp, sp
00000000                            		endc
00000000                            		move.w	(sp)+, sr
00000000                            		bra.w	@instr_end\@
00000000                            	@str\@:
00000000                            		__FSTRING_GenerateDecodedString \1
00000000                            		even
00000000                            	@instr_end\@:
00000000                            
00000000                            	elseif strcmp("\0","run")
00000000                            		jsr		ErrorHandler.__extern__console_only
00000000                            		jsr		\1
00000000                            		bra.s	*
00000000                            
00000000                            	elseif strcmp("\0","setxy")
00000000                            		move.w	sr, -(sp)
00000000                            		movem.l	d0-d1, -(sp)
00000000                            		move.w	\2, -(sp)
00000000                            		move.w	\1, -(sp)
00000000                            		jsr		ErrorHandler.__global__console_setposasxy_stack
00000000                            		addq.w	#4, sp
00000000                            		movem.l	(sp)+, d0-d1
00000000                            		move.w	(sp)+, sr
00000000                            
00000000                            	elseif strcmp("\0","breakline")
00000000                            		move.w	sr, -(sp)
00000000                            		jsr		ErrorHandler.__global__console_startnewline
00000000                            		move.w	(sp)+, sr
00000000                            
00000000                            	else
00000000                            		inform	2,"""\0"" isn't a member of ""Console"""
00000000                            
00000000                            	endc
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __ErrorMessage &
00000000                            		__FSTRING_GenerateArgumentsCode \string
00000000                            		jsr		ErrorHandler
00000000                            		__FSTRING_GenerateDecodedString \string
00000000                            		dc.b	\opts+0
00000000                            		even
00000000                            
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __FSTRING_GenerateArgumentsCode &
00000000                            
00000000                            	__pos:	set 	instr(\string,'%<')		; token position
00000000                            	__stack:set		0						; size of actual stack
00000000                            	__sp:	set		0						; stack displacement
00000000                            
00000000                            	; Parse string itself
00000000                            	while (__pos)
00000000                            
00000000                            		; Retrive expression in brackets following % char
00000000                                	__endpos:	set		instr(__pos+1,\string,'>')
00000000                                	__midpos:	set		instr(__pos+5,\string,' ')
00000000                                	if (__midpos<1)|(__midpos>__endpos)
00000000                            			__midpos: = __endpos
00000000                                	endc
00000000                            		__substr:	substr	__pos+1+1,__endpos-1,\string			; .type ea param
00000000                            		__type:		substr	__pos+1+1,__pos+1+1+1,\string			; .type
00000000                            
00000000                            		; Expression is an effective address (e.g. %(.w d0 hex) )
00000000                            		if "\__type">>8="."
00000000                            			__operand:	substr	__pos+1+1,__midpos-1,\string			; .type ea
00000000                            			__param:	substr	__midpos+1,__endpos-1,\string			; param
00000000                            
00000000                            			if "\__type"=".b"
00000000                            				pushp	"move\__operand\,1(sp)"
00000000                            				pushp	"subq.w	#2, sp"
00000000                            				__stack: = __stack+2
00000000                            				__sp: = __sp+2
00000000                            
00000000                            			elseif "\__type"=".w"
00000000                            				pushp	"move\__operand\,-(sp)"
00000000                            				__stack: = __stack+1
00000000                            				__sp: = __sp+2
00000000                            
00000000                            			elseif "\__type"=".l"
00000000                            				pushp	"move\__operand\,-(sp)"
00000000                            				__stack: = __stack+1
00000000                            				__sp: = __sp+4
00000000                            
00000000                            			else
00000000                            				fatal 'Unrecognized type in string operand: %<\__substr>'
00000000                            			endc
00000000                            		endc
00000000                            
00000000                            		__pos:	set		instr(__pos+1,\string,'%<')
00000000                            	endw
00000000                            
00000000                            	; Generate stack code
00000000                            	rept __stack
00000000                            		popp	__command
00000000                            		\__command
00000000                            	endr
00000000                            
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __FSTRING_GenerateDecodedString &
00000000                            
00000000                            	__lpos:	set		1						; start position
00000000                            	__pos:	set 	instr(\string,'%<')		; token position
00000000                            
00000000                            	while (__pos)
00000000                            
00000000                            		; Write part of string before % token
00000000                            		__substr:	substr	__lpos,__pos-1,\string
00000000                            		dc.b	"\__substr"
00000000                            
00000000                            		; Retrive expression in brakets following % char
00000000                                	__endpos:	set		instr(__pos+1,\string,'>')
00000000                                	__midpos:	set		instr(__pos+5,\string,' ')
00000000                                	if (__midpos<1)|(__midpos>__endpos)
00000000                            			__midpos: = __endpos
00000000                                	endc
00000000                            		__type:		substr	__pos+1+1,__pos+1+1+1,\string			; .type
00000000                            
00000000                            		; Expression is an effective address (e.g. %<.w d0 hex> )
00000000                            		if "\__type">>8="."    
00000000                            			__param:	substr	__midpos+1,__endpos-1,\string			; param
00000000                            			if strlen("\__param")<1
00000000                            				__param: substr ,,"hex"			; if param is ommited, set it to "hex"
00000000                            			endc
00000000                            			if "\__type"=".b"
00000000                            				dc.b	\__param
00000000                            			elseif "\__type"=".w"
00000000                            				dc.b	\__param|1
00000000                            			else
00000000                            				dc.b	\__param|3
00000000                            			endc
00000000                            
00000000                            		; Expression is an inline constant (e.g. %<endl> )
00000000                            		else
00000000                            			__substr:	substr	__pos+1+1,__endpos-1,\string
00000000                            			dc.b	\__substr
00000000                            		endc
00000000                            
00000000                            		__lpos:	set		__endpos+1
00000000                            		__pos:	set		instr(__pos+1,\string,'%<')
00000000                            	endw
00000000                            
00000000                            	; Write part of string before the end
00000000                            	__substr:	substr	__lpos,,\string
00000000                            	dc.b	"\__substr"
00000000                            	dc.b	0
00000000                            
00000000                            	endm
00000000                            	endm
00000000                            
00000000                            		include	"Constants.asm"
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Constants
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00006978                  Size_of_SegaPCM:		equ $6978
00000000                            
00000000                            ; VDP addressses
00000000 =00C00000                  vdp_data_port:		equ $C00000
00000000 =00C00004                  vdp_control_port:	equ $C00004
00000000 =00C00008                  vdp_counter:		equ $C00008
00000000                            
00000000 =00C00011                  psg_input:		equ $C00011
00000000                            
00000000                            ; Z80 addresses
00000000 =00A00000                  z80_ram:		equ $A00000	; start of Z80 RAM
00000000 =00A000EA                  z80_dac3_pitch:		equ $A000EA
00000000 =00A01FFD                  z80_dac_status:		equ $A01FFD
00000000 =00A01FFF                  z80_dac_sample:		equ $A01FFF
00000000 =00A02000                  z80_ram_end:		equ $A02000	; end of non-reserved Z80 RAM
00000000 =00A10001                  z80_version:		equ $A10001
00000000 =00A10002                  z80_port_1_data:	equ $A10002
00000000 =00A10008                  z80_port_1_control:	equ $A10008
00000000 =00A1000A                  z80_port_2_control:	equ $A1000A
00000000 =00A1000C                  z80_expansion_control:	equ $A1000C
00000000 =00A11100                  z80_bus_request:	equ $A11100
00000000 =00A11200                  z80_reset:		equ $A11200
00000000 =00A04000                  ym2612_a0:		equ $A04000
00000000 =00A04001                  ym2612_d0:		equ $A04001
00000000 =00A04002                  ym2612_a1:		equ $A04002
00000000 =00A04003                  ym2612_d1:		equ $A04003
00000000                            
00000000 =00A14000                  security_addr:		equ $A14000
00000000                            
00000000                            ; Sound driver constants
00000000 =00000000                  TrackPlaybackControl:	equ 0		; All tracks
00000000 =00000001                  TrackVoiceControl:	equ 1		; All tracks
00000000 =00000002                  TrackTempoDivider:	equ 2		; All tracks
00000000 =00000004                  TrackDataPointer:	equ 4		; All tracks (4 bytes)
00000000 =00000008                  TrackTranspose:		equ 8		; FM/PSG only (sometimes written to as a word, to include TrackVolume)
00000000 =00000009                  TrackVolume:		equ 9		; FM/PSG only
00000000 =0000000A                  TrackAMSFMSPan:		equ $A		; FM/DAC only
00000000 =0000000B                  TrackVoiceIndex:	equ $B		; FM/PSG only
00000000 =0000000C                  TrackVolEnvIndex:	equ $C		; PSG only
00000000 =0000000D                  TrackStackPointer:	equ $D		; All tracks
00000000 =0000000E                  TrackDurationTimeout:	equ $E		; All tracks
00000000 =0000000F                  TrackSavedDuration:	equ $F		; All tracks
00000000 =00000010                  TrackSavedDAC:		equ $10		; DAC only
00000000 =00000010                  TrackFreq:		equ $10		; FM/PSG only (2 bytes)
00000000 =00000012                  TrackNoteTimeout:	equ $12		; FM/PSG only
00000000 =00000013                  TrackNoteTimeoutMaster:equ $13		; FM/PSG only
00000000 =00000014                  TrackModulationPtr:	equ $14		; FM/PSG only (4 bytes)
00000000 =00000018                  TrackModulationWait:	equ $18		; FM/PSG only
00000000 =00000019                  TrackModulationSpeed:	equ $19		; FM/PSG only
00000000 =0000001A                  TrackModulationDelta:	equ $1A		; FM/PSG only
00000000 =0000001B                  TrackModulationSteps:	equ $1B		; FM/PSG only
00000000 =0000001C                  TrackModulationVal:	equ $1C		; FM/PSG only (2 bytes)
00000000 =0000001E                  TrackDetune:		equ $1E		; FM/PSG only
00000000 =0000001F                  TrackPSGNoise:		equ $1F		; PSG only
00000000 =0000001F                  TrackFeedbackAlgo:	equ $1F		; FM only
00000000 =00000020                  TrackVoicePtr:		equ $20		; FM SFX only (4 bytes)
00000000 =00000024                  TrackLoopCounters:	equ $24		; All tracks (multiple bytes)
00000000                            TrackGoSubStack:	equ TrackSz	; All tracks (multiple bytes. This constant won't get to be used because of an optimisation that just uses TrackSz)
00000000                            
00000000 =00000030                  TrackSz:	equ $30
00000000                            
00000000                            ; VRAM data
00000000 =0000C000                  vram_fg:	equ $C000	; foreground namespace
00000000 =0000E000                  vram_bg:	equ $E000	; background namespace
00000000 =0000F000                  vram_sonic:	equ $F000	; Sonic graphics
00000000 =0000F800                  vram_sprites:	equ $F800	; sprite table
00000000 =0000FC00                  vram_hscroll:	equ $FC00	; horizontal scroll table
00000000                            
00000000                            ; Game modes
00000000                            id_Sega:	equ ptr_GM_Sega-GameModeArray	; $00
00000000                            id_Title:	equ ptr_GM_Title-GameModeArray	; $04
00000000                            id_Level:	equ ptr_GM_Level-GameModeArray	; $08
00000000                            
00000000                            ; Colours
00000000 =00000000                  cBlack:		equ $000		; colour black
00000000 =00000EEE                  cWhite:		equ $EEE		; colour white
00000000 =00000E00                  cBlue:		equ $E00		; colour blue
00000000 =000000E0                  cGreen:		equ $0E0		; colour green
00000000 =0000000E                  cRed:		equ $00E		; colour red
00000000 =000000EE                  cYellow:	equ cGreen+cRed		; colour yellow
00000000 =00000EE0                  cAqua:		equ cGreen+cBlue	; colour aqua
00000000 =00000E0E                  cMagenta:	equ cBlue+cRed		; colour magenta
00000000                            
00000000                            ; Joypad input
00000000 =00000080                  btnStart:	equ %10000000 ; Start button	($80)
00000000 =00000040                  btnA:		equ %01000000 ; A		($40)
00000000 =00000020                  btnC:		equ %00100000 ; C		($20)
00000000 =00000010                  btnB:		equ %00010000 ; B		($10)
00000000 =00000008                  btnR:		equ %00001000 ; Right		($08)
00000000 =00000004                  btnL:		equ %00000100 ; Left		($04)
00000000 =00000002                  btnDn:		equ %00000010 ; Down		($02)
00000000 =00000001                  btnUp:		equ %00000001 ; Up		($01)
00000000 =0000000F                  btnDir:		equ %00001111 ; Any direction	($0F)
00000000 =00000070                  btnABC:		equ %01110000 ; A, B or C	($70)
00000000 =00000007                  bitStart:	equ 7
00000000 =00000006                  bitA:		equ 6
00000000 =00000005                  bitC:		equ 5
00000000 =00000004                  bitB:		equ 4
00000000 =00000003                  bitR:		equ 3
00000000 =00000002                  bitL:		equ 2
00000000 =00000001                  bitDn:		equ 1
00000000 =00000000                  bitUp:		equ 0
00000000                            
00000000                            ; Object variables
00000000 =00000001                  obRender:	equ 1	; bitfield for x/y flip, display mode
00000000 =00000002                  obGfx:		equ 2	; palette line & VRAM setting (2 bytes)
00000000 =00000004                  obMap:		equ 4	; mappings address (4 bytes)
00000000 =00000008                  obX:		equ 8	; x-axis position (2-4 bytes)
00000000 =0000000A                  obScreenY:	equ $A	; y-axis position for screen-fixed items (2 bytes)
00000000 =0000000C                  obY:		equ $C	; y-axis position (2-4 bytes)
00000000 =00000010                  obVelX:		equ $10	; x-axis velocity (2 bytes)
00000000 =00000012                  obVelY:		equ $12	; y-axis velocity (2 bytes)
00000000 =00000014                  obInertia:	equ $14	; potential speed (2 bytes)
00000000 =00000016                  obHeight:	equ $16	; height/2
00000000 =00000017                  obWidth:	equ $17	; width/2
00000000 =00000018                  obPriority:	equ $18	; sprite stack priority -- 0 is front
00000000 =00000019                  obActWid:	equ $19	; action width
00000000 =0000001A                  obFrame:	equ $1A	; current frame displayed
00000000 =0000001B                  obAniFrame:	equ $1B	; current frame in animation script
00000000 =0000001C                  obAnim:		equ $1C	; current animation
00000000 =0000001D                  obNextAni:	equ $1D	; next animation
00000000 =0000001E                  obTimeFrame:	equ $1E	; time to next frame
00000000 =0000001F                  obDelayAni:	equ $1F	; time to delay animation
00000000 =00000020                  obColType:	equ $20	; collision response type
00000000 =00000021                  obColProp:	equ $21	; collision extra property
00000000 =00000022                  obStatus:	equ $22	; orientation or mode
00000000 =00000023                  obRespawnNo:	equ $23	; respawn list index number
00000000 =00000024                  obRoutine:	equ $24	; routine number
00000000 =00000025                  ob2ndRout:	equ $25	; secondary routine number
00000000 =00000026                  obAngle:	equ $26	; angle
00000000 =00000028                  obSubtype:	equ $28	; object subtype
00000000 =00000025                  obSolid:	equ ob2ndRout ; solid status flag
00000000                            
00000000                            ; Object variables used by Sonic
00000000 =00000030                  flashtime:	equ $30	; time between flashes after getting hit
00000000 =00000032                  invtime:	equ $32	; time left for invincibility
00000000 =00000034                  shoetime:	equ $34	; time left for speed shoes
00000000 =0000003D                  standonobject:	equ $3D	; object Sonic stands on
00000000                            
00000000                            ; Object variables (Sonic 2 disassembly nomenclature)
00000000 =00000001                  render_flags:	equ 1	; bitfield for x/y flip, display mode
00000000 =00000002                  art_tile:	equ 2	; palette line & VRAM setting (2 bytes)
00000000 =00000004                  mappings:	equ 4	; mappings address (4 bytes)
00000000 =00000008                  x_pos:		equ 8	; x-axis position (2-4 bytes)
00000000 =0000000C                  y_pos:		equ $C	; y-axis position (2-4 bytes)
00000000 =00000010                  x_vel:		equ $10	; x-axis velocity (2 bytes)
00000000 =00000012                  y_vel:		equ $12	; y-axis velocity (2 bytes)
00000000 =00000016                  y_radius:	equ $16	; height/2
00000000 =00000017                  x_radius:	equ $17	; width/2
00000000 =00000018                  priority:	equ $18	; sprite stack priority -- 0 is front
00000000 =00000019                  width_pixels:	equ $19	; action width
00000000 =0000001A                  mapping_frame:	equ $1A	; current frame displayed
00000000 =0000001B                  anim_frame:	equ $1B	; current frame in animation script
00000000 =0000001C                  anim:		equ $1C	; current animation
00000000 =0000001D                  next_anim:	equ $1D	; next animation
00000000 =0000001E                  anim_frame_duration: equ $1E ; time to next frame
00000000 =00000020                  collision_flags: equ $20 ; collision response type
00000000 =00000021                  collision_property: equ $21 ; collision extra property
00000000 =00000022                  status:		equ $22	; orientation or mode
00000000 =00000023                  respawn_index:	equ $23	; respawn list index number
00000000 =00000024                  routine:	equ $24	; routine number
00000000 =00000025                  routine_secondary: equ $25 ; secondary routine number
00000000 =00000026                  angle:		equ $26	; angle
00000000 =00000028                  subtype:	equ $28	; object subtype
00000000                            
00000000                            ; Animation flags
00000000 =000000FF                  afEnd:		equ $FF	; return to beginning of animation
00000000 =000000FE                  afBack:		equ $FE	; go back (specified number) bytes
00000000 =000000FD                  afChange:	equ $FD	; run specified animation
00000000 =000000FC                  afRoutine:	equ $FC	; increment routine counter
00000000 =000000FB                  afReset:	equ $FB	; reset animation and 2nd object routine counter
00000000 =000000FA                  af2ndRoutine:	equ $FA	; increment 2nd routine counter
00000000 =000000FA                  af2ndRoutine:	equ $FA	; increment 2nd routine counter
00000000                            		include	"Variables.asm"
00000000                            ; Variables (v) and Flags (f)
00000000                            
00000000 =FFFFFC00                  v_regbuffer:	equ $FFFFFC00	; stores registers d0-a7 during an error event ($40 bytes)
00000000 =FFFFFC40                  v_spbuffer:	equ $FFFFFC40	; stores most recent sp address (4 bytes)
00000000 =FFFFFC44                  v_errortype:	equ $FFFFFC44	; error type
00000000                            
00000000 =00FF0000                  v_256x256:	equ   $FF0000	; 256x256 tile mappings ($A400 bytes)
00000000 =FFFFA400                  v_lvllayout:	equ $FFFFA400	; level and background layouts ($400 bytes)
00000000 =FFFFA800                  v_bgscroll_buffer:	equ	$FFFFA800	; background scroll buffer ($200 bytes)
00000000 =FFFFAA00                  v_ngfx_buffer:	equ $FFFFAA00	; Nemesis graphics decompression buffer ($200 bytes)
00000000 =FFFFAC00                  v_spritequeue:	equ $FFFFAC00	; sprite display queue, in order of priority ($400 bytes)
00000000 =FFFFB000                  v_16x16:		equ $FFFFB000	; 16x16 tile mappings
00000000                            
00000000 =FFFFC800                  v_sgfx_buffer:	equ $FFFFC800	; buffered Sonic graphics ($17 cells) ($2E0 bytes)
00000000 =FFFFCB00                  v_tracksonic:	equ $FFFFCB00	; position tracking data for Sonic ($100 bytes)
00000000 =FFFFCC00                  v_hscrolltablebuffer:	equ $FFFFCC00	; scrolling table data (actually $380 bytes, but $400 is reserved for it)
00000000                            
00000000 =FFFFD000                  v_objspace:	equ $FFFFD000	; object variable space ($40 bytes per object) ($2000 bytes)
00000000                            
00000000                            ; Title screen objects
00000000 =FFFFD080                  v_sonicteam	= v_objspace+$80	; object variable space for the "SONIC TEAM PRESENTS" text ($40 bytes)
00000000 =FFFFD040                  v_titlesonic	= v_objspace+$40	; object variable space for Sonic in the title screen ($40 bytes)
00000000 =FFFFD080                  v_pressstart	= v_objspace+$80	; object variable space for the "PRESS START BUTTON" text ($40 bytes)
00000000 =FFFFD0C0                  v_titletm	= v_objspace+$C0	; object variable space for the trademark symbol ($40 bytes)
00000000 =FFFFD100                  v_ttlsonichide	= v_objspace+$100	; object variable space for hiding part of Sonic ($40 bytes)
00000000                            
00000000                            ; Level objects
00000000 =FFFFD000                  v_player	= v_objspace		; object variable space for Sonic ($40 bytes)
00000000 =FFFFD040                  v_hud		= v_objspace+$40	; object variable space for the HUD ($40 bytes)
00000000                            
00000000 =FFFFD080                  v_titlecard	= v_objspace+$80	; object variable space for the title card ($100 bytes)
00000000 =FFFFD080                  v_ttlcardname	= v_titlecard		; object variable space for the title card zone name text ($40 bytes)
00000000 =FFFFD0C0                  v_ttlcardzone	= v_titlecard+$40	; object variable space for the title card "ZONE" text ($40 bytes)
00000000 =FFFFD100                  v_ttlcardact	= v_titlecard+$80	; object variable space for the title card act text ($40 bytes)
00000000 =FFFFD140                  v_ttlcardoval	= v_titlecard+$C0	; object variable space for the title card oval ($40 bytes)
00000000                            
00000000 =FFFFD080                  v_gameovertext1	= v_objspace+$80	; object variable space for the "GAME"/"TIME" in "GAME OVER"/"TIME OVER" text ($40 bytes)
00000000 =FFFFD0C0                  v_gameovertext2	= v_objspace+$C0	; object variable space for the "OVER" in "GAME OVER"/"TIME OVER" text ($40 bytes)
00000000                            
00000000 =FFFFD180                  v_shieldobj	= v_objspace+$180	; object variable space for the shield ($40 bytes)
00000000 =FFFFD200                  v_starsobj1	= v_objspace+$200	; object variable space for the invincibility stars #1 ($40 bytes)
00000000 =FFFFD240                  v_starsobj2	= v_objspace+$240	; object variable space for the invincibility stars #2 ($40 bytes)
00000000 =FFFFD280                  v_starsobj3	= v_objspace+$280	; object variable space for the invincibility stars #3 ($40 bytes)
00000000 =FFFFD2C0                  v_starsobj4	= v_objspace+$2C0	; object variable space for the invincibility stars #4 ($40 bytes)
00000000                            
00000000 =FFFFD300                  v_splash	= v_objspace+$300	; object variable space for the water splash ($40 bytes)
00000000 =FFFFD340                  v_sonicbubbles	= v_objspace+$340	; object variable space for the bubbles that come out of Sonic's mouth/drown countdown ($40 bytes)
00000000 =FFFFD780                  v_watersurface1	= v_objspace+$780	; object variable space for the water surface #1 ($40 bytes)
00000000 =FFFFD7C0                  v_watersurface2	= v_objspace+$7C0	; object variable space for the water surface #1 ($40 bytes)
00000000                            
00000000 =FFFFD5C0                  v_endcard	= v_objspace+$5C0	; object variable space for the level results card ($1C0 bytes)
00000000 =FFFFD5C0                  v_endcardsonic	= v_endcard		; object variable space for the level results card "SONIC HAS" text ($40 bytes)
00000000 =FFFFD600                  v_endcardpassed	= v_endcard+$40		; object variable space for the level results card "PASSED" text ($40 bytes)
00000000 =FFFFD640                  v_endcardact	= v_endcard+$80		; object variable space for the level results card act text ($40 bytes)
00000000 =FFFFD680                  v_endcardscore	= v_endcard+$C0		; object variable space for the level results card score tally ($40 bytes)
00000000 =FFFFD6C0                  v_endcardtime	= v_endcard+$100	; object variable space for the level results card time bonus tally ($40 bytes)
00000000 =FFFFD700                  v_endcardring	= v_endcard+$140	; object variable space for the level results card ring bonus tally ($40 bytes)
00000000 =FFFFD740                  v_endcardoval	= v_endcard+$180	; object variable space for the level results card oval ($40 bytes)
00000000                            
00000000 =FFFFD800                  v_lvlobjspace	= v_objspace+$800	; level object variable space ($1800 bytes)
00000000 =FFFFF000                  v_lvlobjend	= v_lvlobjspace+$1800
00000000                            
00000000                            ; Special Stage objects
00000000 =FFFFD5C0                  v_ssrescard	= v_objspace+$5C0	; object variable space for the Special Stage results card ($140 bytes)
00000000 =FFFFD5C0                  v_ssrestext	= v_ssrescard		; object variable space for the Special Stage results card text ($40 bytes)
00000000 =FFFFD600                  v_ssresscore	= v_ssrescard+$40	; object variable space for the Special Stage results card score tally ($40 bytes)
00000000 =FFFFD640                  v_ssresring	= v_ssrescard+$80	; object variable space for the Special Stage results card ring bonus tally ($40 bytes)
00000000 =FFFFD680                  v_ssresoval	= v_ssrescard+$C0	; object variable space for the Special Stage results card oval ($40 bytes)
00000000 =FFFFD6C0                  v_ssrescontinue	= v_ssrescard+$100	; object variable space for the Special Stage results card continue icon ($40 bytes)
00000000 =FFFFD800                  v_ssresemeralds	= v_objspace+$800	; object variable space for the emeralds in the Special Stage results ($180 bytes)
00000000                            
00000000                            ; Continue screen objects
00000000 =FFFFD040                  v_continuetext	= v_objspace+$40	; object variable space for the continue screen text ($40 bytes)
00000000 =FFFFD080                  v_continuelight	= v_objspace+$80	; object variable space for the continue screen light spot ($40 bytes)
00000000 =FFFFD0C0                  v_continueicon	= v_objspace+$C0	; object variable space for the continue screen icon ($40 bytes)
00000000                            
00000000                            ; Ending objects
00000000 =FFFFD400                  v_endemeralds	= v_objspace+$400	; object variable space for the emeralds in the ending ($180 bytes)
00000000 =FFFFD400                  v_endlogo	= v_objspace+$400	; object variable space for the logo in the ending ($40 bytes)
00000000                            
00000000                            ; Credits objects
00000000 =FFFFD080                  v_credits	= v_objspace+$80	; object variable space for the credits text ($40 bytes)
00000000 =FFFFD080                  v_endeggman	= v_objspace+$80	; object variable space for Eggman after the credits ($40 bytes)
00000000 =FFFFD0C0                  v_tryagain	= v_objspace+$C0	; object variable space for the "TRY AGAIN" text ($40 bytes)
00000000 =FFFFD800                  v_eggmanchaos	= v_objspace+$800	; object variable space for the emeralds juggled by Eggman ($180 bytes)
00000000                            
00000000 =FFFFF000                  v_snddriver_ram:	equ $FFFFF000 ; start of RAM for the sound driver data ($5C0 bytes)
00000000                            
00000000                            ; =================================================================================
00000000                            ; From here on, until otherwise stated, all offsets are relative to v_snddriver_ram
00000000                            ; =================================================================================
00000000 =00000000                  v_startofvariables:	equ $000
00000000 =00000000                  v_sndprio:		equ $000	; sound priority (priority of new music/SFX must be higher or equal to this value or it won't play; bit 7 of priority being set prevents this value from changing)
00000000 =00000001                  v_main_tempo_timeout:	equ $001	; Counts down to zero; when zero, resets to next value and delays song by 1 frame
00000000 =00000002                  v_main_tempo:		equ $002	; Used for music only
00000000 =00000003                  f_pausemusic:		equ $003	; flag set to stop music when paused
00000000 =00000004                  v_fadeout_counter:	equ $004
00000000                            
00000000 =00000006                  v_fadeout_delay:	equ $006
00000000 =00000007                  v_communication_byte:	equ $007	; used in Ristar to sync with a boss' attacks; unused here
00000000 =00000008                  f_updating_dac:		equ $008	; $80 if updating DAC, $00 otherwise
00000000 =00000009                  v_sound_id:		equ $009	; sound or music copied from below
00000000 =0000000A                  v_soundqueue0:		equ $00A	; sound or music to play
00000000 =0000000B                  v_soundqueue1:		equ $00B	; special sound to play
00000000 =0000000C                  v_soundqueue2:		equ $00C	; unused sound to play
00000000                            
00000000 =0000000E                  f_voice_selector:	equ $00E	; $00 = use music voice pointer; $40 = use special voice pointer; $80 = use track voice pointer
00000000                            
00000000 =00000018                  v_voice_ptr:		equ $018	; voice data pointer (4 bytes)
00000000                            
00000000 =00000020                  v_special_voice_ptr:	equ $020	; voice data pointer for special SFX ($D0-$DF) (4 bytes)
00000000                            
00000000 =00000024                  f_fadein_flag:		equ $024	; Flag for fade in
00000000 =00000025                  v_fadein_delay:		equ $025
00000000 =00000026                  v_fadein_counter:	equ $026	; Timer for fade in/out
00000000 =00000027                  f_1up_playing:		equ $027	; flag indicating 1-up song is playing
00000000 =00000028                  v_tempo_mod:		equ $028	; music - tempo modifier
00000000 =00000029                  v_speeduptempo:		equ $029	; music - tempo modifier with speed shoes
00000000 =0000002A                  f_speedup:		equ $02A	; flag indicating whether speed shoes tempo is on ($80) or off ($00)
00000000 =0000002B                  v_ring_speaker:		equ $02B	; which speaker the "ring" sound is played in (00 = right; 01 = left)
00000000 =0000002C                  f_push_playing:		equ $02C	; if set, prevents further push sounds from playing
00000000                            
00000000 =00000040                  v_music_track_ram:	equ $040	; Start of music RAM
00000000                            
00000000 =00000040                  v_music_fmdac_tracks:	equ v_music_track_ram+TrackSz*0
00000000 =00000040                  v_music_dac_track:	equ v_music_fmdac_tracks+TrackSz*0
00000000 =00000070                  v_music_fm_tracks:	equ v_music_fmdac_tracks+TrackSz*1
00000000 =00000070                  v_music_fm1_track:	equ v_music_fm_tracks+TrackSz*0
00000000 =000000A0                  v_music_fm2_track:	equ v_music_fm_tracks+TrackSz*1
00000000 =000000D0                  v_music_fm3_track:	equ v_music_fm_tracks+TrackSz*2
00000000 =00000100                  v_music_fm4_track:	equ v_music_fm_tracks+TrackSz*3
00000000 =00000130                  v_music_fm5_track:	equ v_music_fm_tracks+TrackSz*4
00000000 =00000160                  v_music_fm6_track:	equ v_music_fm_tracks+TrackSz*5
00000000 =00000190                  v_music_fm_tracks_end:	equ v_music_fm_tracks+TrackSz*6
00000000 =00000190                  v_music_fmdac_tracks_end:	equ v_music_fm_tracks_end
00000000 =00000190                  v_music_psg_tracks:	equ v_music_fmdac_tracks_end
00000000 =00000190                  v_music_psg1_track:	equ v_music_psg_tracks+TrackSz*0
00000000 =000001C0                  v_music_psg2_track:	equ v_music_psg_tracks+TrackSz*1
00000000 =000001F0                  v_music_psg3_track:	equ v_music_psg_tracks+TrackSz*2
00000000 =00000220                  v_music_psg_tracks_end:	equ v_music_psg_tracks+TrackSz*3
00000000 =00000220                  v_music_track_ram_end:	equ v_music_psg_tracks_end
00000000                            
00000000 =00000220                  v_sfx_track_ram:	equ v_music_track_ram_end	; Start of SFX RAM, straight after the end of music RAM
00000000                            
00000000 =00000220                  v_sfx_fm_tracks:	equ v_sfx_track_ram+TrackSz*0
00000000 =00000220                  v_sfx_fm3_track:	equ v_sfx_fm_tracks+TrackSz*0
00000000 =00000250                  v_sfx_fm4_track:	equ v_sfx_fm_tracks+TrackSz*1
00000000 =00000280                  v_sfx_fm5_track:	equ v_sfx_fm_tracks+TrackSz*2
00000000 =000002B0                  v_sfx_fm_tracks_end:	equ v_sfx_fm_tracks+TrackSz*3
00000000 =000002B0                  v_sfx_psg_tracks:	equ v_sfx_fm_tracks_end
00000000 =000002B0                  v_sfx_psg1_track:	equ v_sfx_psg_tracks+TrackSz*0
00000000 =000002E0                  v_sfx_psg2_track:	equ v_sfx_psg_tracks+TrackSz*1
00000000 =00000310                  v_sfx_psg3_track:	equ v_sfx_psg_tracks+TrackSz*2
00000000 =00000340                  v_sfx_psg_tracks_end:	equ v_sfx_psg_tracks+TrackSz*3
00000000 =00000340                  v_sfx_track_ram_end:	equ v_sfx_psg_tracks_end
00000000                            
00000000 =00000340                  v_spcsfx_track_ram:	equ v_sfx_track_ram_end	; Start of special SFX RAM, straight after the end of SFX RAM
00000000                            
00000000 =00000340                  v_spcsfx_fm4_track:	equ v_spcsfx_track_ram+TrackSz*0
00000000 =00000370                  v_spcsfx_psg3_track:	equ v_spcsfx_track_ram+TrackSz*1
00000000 =000003A0                  v_spcsfx_track_ram_end:	equ v_spcsfx_track_ram+TrackSz*2
00000000                            
00000000 =000003A0                  v_1up_ram_copy:		equ v_spcsfx_track_ram_end
00000000                            
00000000                            ; =================================================================================
00000000                            ; From here on, no longer relative to sound driver RAM
00000000                            ; =================================================================================
00000000                            
00000000 =FFFFF600                  v_gamemode:	equ $FFFFF600	; game mode (00=Sega; 04=Title; 08=Demo; 0C=Level; 10=SS; 14=Cont; 18=End; 1C=Credit; +8C=PreLevel)
00000000 =FFFFF602                  v_jpadhold2:	equ $FFFFF602	; joypad input - held, duplicate
00000000 =FFFFF603                  v_jpadpress2:	equ $FFFFF603	; joypad input - pressed, duplicate
00000000 =FFFFF604                  v_jpadhold1:	equ $FFFFF604	; joypad input - held
00000000 =FFFFF605                  v_jpadpress1:	equ $FFFFF605	; joypad input - pressed
00000000                            
00000000 =FFFFF60C                  v_vdp_buffer1:	equ $FFFFF60C	; VDP instruction buffer (2 bytes)
00000000                            
00000000 =FFFFF614                  v_demolength:	equ $FFFFF614	; the length of a demo in frames (2 bytes)
00000000 =FFFFF616                  v_scrposy_vdp:	equ $FFFFF616	; screen position y (VDP) (2 bytes)
00000000 =FFFFF618                  v_bgscrposy_vdp:	equ $FFFFF618	; background screen position y (VDP) (2 bytes)
00000000 =FFFFF61A                  v_scrposx_vdp:	equ $FFFFF61A	; screen position x (VDP) (2 bytes)
00000000 =FFFFF61C                  v_bgscrposx_vdp:	equ $FFFFF61C	; background screen position x (VDP) (2 bytes)
00000000 =FFFFF61E                  v_bg3scrposy_vdp:	equ $FFFFF61E	; (2 bytes)
00000000 =FFFFF620                  v_bg3scrposx_vdp:	equ $FFFFF620	; (2 bytes)
00000000                            
00000000 =FFFFF624                  v_hbla_hreg:	equ $FFFFF624	; VDP H.interrupt register buffer (8Axx) (2 bytes)
00000000 =FFFFF625                  v_hbla_line:	equ $FFFFF625	; screen line where water starts and palette is changed by HBlank
00000000 =FFFFF626                  v_pfade_start:	equ $FFFFF626	; palette fading - start position in bytes
00000000 =FFFFF627                  v_pfade_size:	equ $FFFFF627	; palette fading - number of colours
00000000 =FFFFF62A                  v_vbla_routine:	equ $FFFFF62A	; VBlank - routine counter
00000000 =FFFFF62C                  v_spritecount:	equ $FFFFF62C	; number of sprites on-screen
00000000 =FFFFF632                  v_pcyc_num:	equ $FFFFF632	; palette cycling - current reference number (2 bytes)
00000000 =FFFFF634                  v_pcyc_time:	equ $FFFFF634	; palette cycling - time until the next change (2 bytes)
00000000 =FFFFF636                  v_random:	equ $FFFFF636	; pseudo random number buffer (4 bytes)
00000000 =FFFFF63A                  f_pause:		equ $FFFFF63A	; flag set to pause the game (2 bytes)
00000000 =FFFFF640                  v_vdp_buffer2:	equ $FFFFF640	; VDP instruction buffer (2 bytes)
00000000 =FFFFF644                  f_hbla_pal:	equ $FFFFF644	; flag set to change palette during HBlank (0000 = no; 0001 = change) (2 bytes)
00000000 =FFFFF646                  v_waterpos1:	equ $FFFFF646	; water height, actual (2 bytes)
00000000 =FFFFF648                  v_waterpos2:	equ $FFFFF648	; water height, ignoring sway (2 bytes)
00000000 =FFFFF64A                  v_waterpos3:	equ $FFFFF64A	; water height, next target (2 bytes)
00000000 =FFFFF64C                  f_water:		equ $FFFFF64C	; flag set for water
00000000 =FFFFF64D                  v_wtr_routine:	equ $FFFFF64D	; water event - routine counter
00000000 =FFFFF64E                  f_wtr_state:	equ $FFFFF64E	; water palette state when water is above/below the screen (00 = partly/all dry; 01 = all underwater)
00000000                            
00000000 =FFFFF650                  v_pal_buffer:	equ $FFFFF650	; palette data buffer (used for palette cycling) ($30 bytes)
00000000 =FFFFF680                  v_plc_buffer:	equ $FFFFF680	; pattern load cues buffer (maximum $10 PLCs) ($60 bytes)
00000000 =FFFFF6E0                  v_ptrnemcode:	equ $FFFFF6E0	; pointer for nemesis decompression code ($1502 or $150C) (4 bytes)
00000000                            
00000000 =FFFFF6F8                  f_plc_execute:	equ $FFFFF6F8	; flag set for pattern load cue execution (2 bytes)
00000000                            
00000000 =FFFFF700                  v_screenposx:	equ $FFFFF700	; screen position x (2 bytes)
00000000 =FFFFF704                  v_screenposy:	equ $FFFFF704	; screen position y (2 bytes)
00000000 =FFFFF708                  v_bgscreenposx:	equ $FFFFF708	; background screen position x (2 bytes)
00000000 =FFFFF70C                  v_bgscreenposy:	equ $FFFFF70C	; background screen position y (2 bytes)
00000000 =FFFFF710                  v_bg2screenposx:	equ $FFFFF710	; 2 bytes
00000000 =FFFFF714                  v_bg2screenposy:	equ $FFFFF714	; 2 bytes
00000000 =FFFFF718                  v_bg3screenposx:	equ $FFFFF718	; 2 bytes
00000000 =FFFFF71C                  v_bg3screenposy:	equ $FFFFF71C	; 2 bytes
00000000                            
00000000 =FFFFF720                  v_limitleft1:	equ $FFFFF720	; left level boundary (2 bytes)
00000000 =FFFFF722                  v_limitright1:	equ $FFFFF722	; right level boundary (2 bytes)
00000000 =FFFFF724                  v_limittop1:	equ $FFFFF724	; top level boundary (2 bytes)
00000000 =FFFFF726                  v_limitbtm1:	equ $FFFFF726	; bottom level boundary (2 bytes)
00000000 =FFFFF728                  v_limitleft2:	equ $FFFFF728	; left level boundary (2 bytes)
00000000 =FFFFF72A                  v_limitright2:	equ $FFFFF72A	; right level boundary (2 bytes)
00000000 =FFFFF72C                  v_limittop2:	equ $FFFFF72C	; top level boundary (2 bytes)
00000000 =FFFFF72E                  v_limitbtm2:	equ $FFFFF72E	; bottom level boundary (2 bytes)
00000000                            
00000000 =FFFFF732                  v_limitleft3:	equ $FFFFF732	; left level boundary, at the end of an act (2 bytes)
00000000                            
00000000 =FFFFF73A                  v_scrshiftx:	equ $FFFFF73A	; x-screen shift (new - last) * $100
00000000 =FFFFF73C                  v_scrshifty:	equ $FFFFF73C	; y-screen shift (new - last) * $100
00000000                            
00000000 =FFFFF73E                  v_lookshift:	equ $FFFFF73E	; screen shift when Sonic looks up/down (2 bytes)
00000000 =FFFFF742                  v_dle_routine:	equ $FFFFF742	; dynamic level event - routine counter
00000000 =FFFFF744                  f_nobgscroll:	equ $FFFFF744	; flag set to cancel background scrolling
00000000                            
00000000 =FFFFF74A                  v_fg_xblock:	equ	$FFFFF74A	; foreground x-block parity (for redraw)
00000000 =FFFFF74B                  v_fg_yblock:	equ	$FFFFF74B	; foreground y-block parity (for redraw)
00000000 =FFFFF74C                  v_bg1_xblock:	equ	$FFFFF74C	; background x-block parity (for redraw)
00000000 =FFFFF74D                  v_bg1_yblock:	equ	$FFFFF74D	; background y-block parity (for redraw)
00000000 =FFFFF74E                  v_bg2_xblock:	equ	$FFFFF74E	; secondary background x-block parity (for redraw)
00000000 =FFFFF74F                  v_bg2_yblock:	equ	$FFFFF74F	; secondary background y-block parity (unused)
00000000 =FFFFF750                  v_bg3_xblock:	equ	$FFFFF750	; teritary background x-block parity (for redraw)
00000000 =FFFFF751                  v_bg3_yblock:	equ	$FFFFF751	; teritary background y-block parity (unused)
00000000                            
00000000 =FFFFF754                  v_fg_scroll_flags:	equ $FFFFF754	; screen redraw flags for foreground
00000000 =FFFFF756                  v_bg1_scroll_flags:	equ $FFFFF756	; screen redraw flags for background 1
00000000 =FFFFF758                  v_bg2_scroll_flags:	equ $FFFFF758	; screen redraw flags for background 2
00000000 =FFFFF75A                  v_bg3_scroll_flags:	equ $FFFFF75A	; screen redraw flags for background 3
00000000 =FFFFF75C                  f_bgscrollvert:	equ $FFFFF75C	; flag for vertical background scrolling
00000000 =FFFFF760                  v_sonspeedmax:	equ $FFFFF760	; Sonic's maximum speed (2 bytes)
00000000 =FFFFF762                  v_sonspeedacc:	equ $FFFFF762	; Sonic's acceleration (2 bytes)
00000000 =FFFFF764                  v_sonspeeddec:	equ $FFFFF764	; Sonic's deceleration (2 bytes)
00000000 =FFFFF766                  v_sonframenum:	equ $FFFFF766	; frame to display for Sonic
00000000 =FFFFF767                  f_sonframechg:	equ $FFFFF767	; flag set to update Sonic's sprite frame
00000000 =FFFFF768                  v_anglebuffer:	equ $FFFFF768	; angle of collision block that Sonic or object is standing on
00000000                            
00000000 =FFFFF76C                  v_opl_routine:	equ $FFFFF76C	; ObjPosLoad - routine counter
00000000 =FFFFF76E                  v_opl_screen:	equ $FFFFF76E	; ObjPosLoad - screen variable
00000000 =FFFFF770                  v_opl_data:	equ $FFFFF770	; ObjPosLoad - data buffer ($10 bytes)
00000000                            
00000000 =FFFFF780                  v_ssangle:	equ $FFFFF780	; Special Stage angle (2 bytes)
00000000 =FFFFF782                  v_ssrotate:	equ $FFFFF782	; Special Stage rotation speed (2 bytes)
00000000 =FFFFF790                  v_btnpushtime1:	equ $FFFFF790	; button push duration - in level (2 bytes)
00000000 =FFFFF792                  v_btnpushtime2:	equ $FFFFF792	; button push duration - in demo (2 bytes)
00000000 =FFFFF794                  v_palchgspeed:	equ $FFFFF794	; palette fade/transition speed (0 is fastest) (2 bytes)
00000000 =FFFFF796                  v_collindex:	equ $FFFFF796	; ROM address for collision index of current level (4 bytes)
00000000 =FFFFF79A                  v_palss_num:	equ $FFFFF79A	; palette cycling in Special Stage - reference number (2 bytes)
00000000 =FFFFF79C                  v_palss_time:	equ $FFFFF79C	; palette cycling in Special Stage - time until next change (2 bytes)
00000000                            
00000000 =FFFFF7A4                  v_obj31ypos:	equ $FFFFF7A4	; y-position of object 31 (MZ stomper) (2 bytes)
00000000 =FFFFF7A7                  v_bossstatus:	equ $FFFFF7A7	; status of boss and prison capsule (01 = boss defeated; 02 = prison opened)
00000000 =FFFFF7A8                  v_trackpos:	equ $FFFFF7A8	; position tracking reference number (2 bytes)
00000000 =FFFFF7A9                  v_trackbyte:	equ $FFFFF7A9	; low byte for position tracking
00000000 =FFFFF7AA                  f_lockscreen:	equ $FFFFF7AA	; flag set to lock screen during bosses
00000000 =FFFFF7AC                  v_256loop1:	equ $FFFFF7AC	; 256x256 level tile which contains a loop (GHZ/SLZ)
00000000 =FFFFF7AD                  v_256loop2:	equ $FFFFF7AD	; 256x256 level tile which contains a loop (GHZ/SLZ)
00000000 =FFFFF7AE                  v_256roll1:	equ $FFFFF7AE	; 256x256 level tile which contains a roll tunnel (GHZ)
00000000 =FFFFF7AF                  v_256roll2:	equ $FFFFF7AF	; 256x256 level tile which contains a roll tunnel (GHZ)
00000000 =FFFFF7B0                  v_lani0_frame:	equ $FFFFF7B0	; level graphics animation 0 - current frame
00000000 =FFFFF7B1                  v_lani0_time:	equ $FFFFF7B1	; level graphics animation 0 - time until next frame
00000000 =FFFFF7B2                  v_lani1_frame:	equ $FFFFF7B2	; level graphics animation 1 - current frame
00000000 =FFFFF7B3                  v_lani1_time:	equ $FFFFF7B3	; level graphics animation 1 - time until next frame
00000000 =FFFFF7B4                  v_lani2_frame:	equ $FFFFF7B4	; level graphics animation 2 - current frame
00000000 =FFFFF7B5                  v_lani2_time:	equ $FFFFF7B5	; level graphics animation 2 - time until next frame
00000000 =FFFFF7B6                  v_lani3_frame:	equ $FFFFF7B6	; level graphics animation 3 - current frame
00000000 =FFFFF7B7                  v_lani3_time:	equ $FFFFF7B7	; level graphics animation 3 - time until next frame
00000000 =FFFFF7B8                  v_lani4_frame:	equ $FFFFF7B8	; level graphics animation 4 - current frame
00000000 =FFFFF7B9                  v_lani4_time:	equ $FFFFF7B9	; level graphics animation 4 - time until next frame
00000000 =FFFFF7BA                  v_lani5_frame:	equ $FFFFF7BA	; level graphics animation 5 - current frame
00000000 =FFFFF7BB                  v_lani5_time:	equ $FFFFF7BB	; level graphics animation 5 - time until next frame
00000000 =FFFFF7BE                  v_gfxbigring:	equ $FFFFF7BE	; settings for giant ring graphics loading (2 bytes)
00000000 =FFFFF7C0                  f_conveyrev:	equ $FFFFF7C0	; flag set to reverse conveyor belts in LZ/SBZ
00000000 =FFFFF7C1                  v_obj63:	equ $FFFFF7C1	; object 63 (LZ/SBZ platforms) variables (6 bytes)
00000000 =FFFFF7C7                  f_wtunnelmode:	equ $FFFFF7C7	; LZ water tunnel mode
00000000 =FFFFF7C8                  f_playerctrl:	equ $FFFFF7C8	; Player control override flags (object ineraction, control enable)
00000000 =FFFFF7C9                  f_wtunnelallow:	equ $FFFFF7C9	; LZ water tunnels (00 = enabled; 01 = disabled)
00000000 =FFFFF7CA                  f_slidemode:	equ $FFFFF7CA	; LZ water slide mode
00000000 =FFFFF7CB                  v_obj6B:	equ $FFFFF7CB	; object 6B (SBZ stomper) variable
00000000 =FFFFF7CC                  f_lockctrl:	equ $FFFFF7CC	; flag set to lock controls during ending sequence
00000000 =FFFFF7CD                  f_bigring:	equ $FFFFF7CD	; flag set when Sonic collects the giant ring
00000000 =FFFFF7D0                  v_itembonus:	equ $FFFFF7D0	; item bonus from broken enemies, blocks etc. (2 bytes)
00000000 =FFFFF7D2                  v_timebonus:	equ $FFFFF7D2	; time bonus at the end of an act (2 bytes)
00000000 =FFFFF7D4                  v_ringbonus:	equ $FFFFF7D4	; ring bonus at the end of an act (2 bytes)
00000000 =FFFFF7D6                  f_endactbonus:	equ $FFFFF7D6	; time/ring bonus update flag at the end of an act
00000000 =FFFFF7D7                  v_sonicend:	equ $FFFFF7D7	; routine counter for Sonic in the ending sequence
00000000 =FFFFF7D8                  v_lz_deform:	equ $FFFFF7D8	; LZ deformtaion offset, in units of $80 (2 bytes)
00000000 =FFFFF7E0                  f_switch:	equ $FFFFF7E0	; flags set when Sonic stands on a switch ($10 bytes)
00000000 =FFFFF7F0                  v_scroll_block_1_size:	equ $FFFFF7F0	; (2 bytes)
00000000 =FFFFF7F2                  v_scroll_block_2_size:	equ $FFFFF7F2	; unused (2 bytes)
00000000 =FFFFF7F4                  v_scroll_block_3_size:	equ $FFFFF7F4	; unused (2 bytes)
00000000 =FFFFF7F6                  v_scroll_block_4_size:	equ $FFFFF7F6	; unused (2 bytes)
00000000                            
00000000 =FFFFF800                  v_spritetablebuffer:	equ $FFFFF800 ; sprite table ($280 bytes, last $80 bytes are overwritten by v_pal_water_dup)
00000000 =FFFFFA00                  v_pal_water_dup:	equ $FFFFFA00 ; duplicate underwater palette, used for transitions ($80 bytes)
00000000 =FFFFFA80                  v_pal_water:	equ $FFFFFA80	; main underwater palette ($80 bytes)
00000000 =FFFFFB00                  v_pal_dry:	equ $FFFFFB00	; main palette ($80 bytes)
00000000 =FFFFFB80                  v_pal_dry_dup:	equ $FFFFFB80	; duplicate palette, used for transitions ($80 bytes)
00000000 =FFFFFC00                  v_objstate:	equ $FFFFFC00	; object state list ($200 bytes)
00000000                            
00000000                            
00000000 =FFFFFE00                  v_systemstack:	equ $FFFFFE00
00000000 =FFFFFE02                  f_restart:	equ $FFFFFE02	; restart level flag (2 bytes)
00000000 =FFFFFE04                  v_framecount:	equ $FFFFFE04	; frame counter (adds 1 every frame) (2 bytes)
00000000 =FFFFFE05                  v_framebyte:	equ v_framecount+1; low byte for frame counter
00000000 =FFFFFE06                  v_debugitem:	equ $FFFFFE06	; debug item currently selected (NOT the object number of the item)
00000000 =FFFFFE08                  v_debuguse:	equ $FFFFFE08	; debug mode use & routine counter (when Sonic is a ring/item) (2 bytes)
00000000 =FFFFFE0A                  v_debugxspeed:	equ $FFFFFE0A	; debug mode - horizontal speed
00000000 =FFFFFE0B                  v_debugyspeed:	equ $FFFFFE0B	; debug mode - vertical speed
00000000 =FFFFFE0C                  v_vbla_count:	equ $FFFFFE0C	; vertical interrupt counter (adds 1 every VBlank) (4 bytes)
00000000 =FFFFFE0E                  v_vbla_word:	equ v_vbla_count+2 ; low word for vertical interrupt counter (2 bytes)
00000000 =FFFFFE0F                  v_vbla_byte:	equ v_vbla_word+1	; low byte for vertical interrupt counter
00000000 =FFFFFE10                  v_zone:		equ $FFFFFE10	; current zone number
00000000 =FFFFFE11                  v_act:		equ $FFFFFE11	; current act number
00000000 =FFFFFE12                  v_lives:		equ $FFFFFE12	; number of lives
00000000 =FFFFFE14                  v_air:		equ $FFFFFE14	; air remaining while underwater (2 bytes)
00000000 =FFFFFE15                  v_airbyte:	equ v_air+1	; low byte for air
00000000 =FFFFFE16                  v_lastspecial:	equ $FFFFFE16	; last special stage number
00000000 =FFFFFE18                  v_continues:	equ $FFFFFE18	; number of continues
00000000 =FFFFFE1A                  f_timeover:	equ $FFFFFE1A	; time over flag
00000000 =FFFFFE1B                  v_lifecount:	equ $FFFFFE1B	; lives counter value (for actual number, see "v_lives")
00000000 =FFFFFE1C                  f_lifecount:	equ $FFFFFE1C	; lives counter update flag
00000000 =FFFFFE1D                  f_ringcount:	equ $FFFFFE1D	; ring counter update flag
00000000 =FFFFFE1E                  f_timecount:	equ $FFFFFE1E	; time counter update flag
00000000 =FFFFFE1F                  f_scorecount:	equ $FFFFFE1F	; score counter update flag
00000000 =FFFFFE20                  v_rings:		equ $FFFFFE20	; rings (2 bytes)
00000000 =FFFFFE21                  v_ringbyte:	equ v_rings+1	; low byte for rings
00000000 =FFFFFE22                  v_time:		equ $FFFFFE22	; time (4 bytes)
00000000 =FFFFFE23                  v_timemin:	equ $FFFFFE23	; time - minutes
00000000 =FFFFFE24                  v_timesec:	equ $FFFFFE24	; time - seconds
00000000 =FFFFFE25                  v_timecent:	equ $FFFFFE25	; time - centiseconds
00000000 =FFFFFE26                  v_score:		equ $FFFFFE26	; score (4 bytes)
00000000 =FFFFFE2C                  v_shield:	equ $FFFFFE2C	; shield status (00 = no; 01 = yes)
00000000 =FFFFFE2D                  v_invinc:	equ $FFFFFE2D	; invinciblity status (00 = no; 01 = yes)
00000000 =FFFFFE2E                  v_shoes:		equ $FFFFFE2E	; speed shoes status (00 = no; 01 = yes)
00000000 =FFFFFE30                  v_lastlamp:	equ $FFFFFE30	; number of the last lamppost you hit
00000000 =FFFFFE32                  v_lamp_xpos:	equ v_lastlamp+2	; x-axis for Sonic to respawn at lamppost (2 bytes)
00000000 =FFFFFE34                  v_lamp_ypos:	equ v_lastlamp+4	; y-axis for Sonic to respawn at lamppost (2 bytes)
00000000 =FFFFFE36                  v_lamp_rings:	equ v_lastlamp+6	; rings stored at lamppost (2 bytes)
00000000 =FFFFFE38                  v_lamp_time:	equ v_lastlamp+8	; time stored at lamppost (2 bytes)
00000000 =FFFFFE3C                  v_lamp_dle:	equ v_lastlamp+$C	; dynamic level event routine counter at lamppost
00000000 =FFFFFE3E                  v_lamp_limitbtm:	equ v_lastlamp+$E	; level bottom boundary at lamppost (2 bytes)
00000000 =FFFFFE40                  v_lamp_scrx:	equ v_lastlamp+$10 ; x-axis screen at lamppost (2 bytes)
00000000 =FFFFFE42                  v_lamp_scry:	equ v_lastlamp+$12 ; y-axis screen at lamppost (2 bytes)
00000000                            
00000000 =FFFFFE50                  v_lamp_wtrpos:	equ v_lastlamp+$20 ; water position at lamppost (2 bytes)
00000000 =FFFFFE52                  v_lamp_wtrrout:	equ v_lastlamp+$22 ; water routine at lamppost
00000000 =FFFFFE53                  v_lamp_wtrstat:	equ v_lastlamp+$23 ; water state at lamppost
00000000 =FFFFFE54                  v_lamp_lives:	equ v_lastlamp+$24 ; lives counter at lamppost
00000000 =FFFFFE57                  v_emeralds:	equ $FFFFFE57	; number of chaos emeralds
00000000 =FFFFFE58                  v_emldlist:	equ $FFFFFE58	; which individual emeralds you have (00 = no; 01 = yes) (6 bytes)
00000000 =FFFFFE5E                  v_oscillate:	equ $FFFFFE5E	; values which oscillate - for swinging platforms, et al ($42 bytes)
00000000 =FFFFFEC0                  v_ani0_time:	equ $FFFFFEC0	; synchronised sprite animation 0 - time until next frame (used for synchronised animations)
00000000 =FFFFFEC1                  v_ani0_frame:	equ $FFFFFEC1	; synchronised sprite animation 0 - current frame
00000000 =FFFFFEC2                  v_ani1_time:	equ $FFFFFEC2	; synchronised sprite animation 1 - time until next frame
00000000 =FFFFFEC3                  v_ani1_frame:	equ $FFFFFEC3	; synchronised sprite animation 1 - current frame
00000000 =FFFFFEC4                  v_ani2_time:	equ $FFFFFEC4	; synchronised sprite animation 2 - time until next frame
00000000 =FFFFFEC5                  v_ani2_frame:	equ $FFFFFEC5	; synchronised sprite animation 2 - current frame
00000000 =FFFFFEC6                  v_ani3_time:	equ $FFFFFEC6	; synchronised sprite animation 3 - time until next frame
00000000 =FFFFFEC7                  v_ani3_frame:	equ $FFFFFEC7	; synchronised sprite animation 3 - current frame
00000000 =FFFFFEC8                  v_ani3_buf:	equ $FFFFFEC8	; synchronised sprite animation 3 - info buffer (2 bytes)
00000000 =FFFFFEF0                  v_limittopdb:	equ $FFFFFEF0	; level upper boundary, buffered for debug mode (2 bytes)
00000000 =FFFFFEF2                  v_limitbtmdb:	equ $FFFFFEF2	; level bottom boundary, buffered for debug mode (2 bytes)
00000000                            
00000000 =FFFFFF10                  v_screenposx_dup:	equ $FFFFFF10	; screen position x (duplicate) (2 bytes)
00000000 =FFFFFF14                  v_screenposy_dup:	equ $FFFFFF14	; screen position y (duplicate) (2 bytes)
00000000 =FFFFFF18                  v_bgscreenposx_dup:	equ $FFFFFF18	; background screen position x (duplicate) (2 bytes)
00000000 =FFFFFF1C                  v_bgscreenposy_dup:	equ $FFFFFF1C	; background screen position y (duplicate) (2 bytes)
00000000 =FFFFFF20                  v_bg2screenposx_dup:	equ $FFFFFF20	; 2 bytes
00000000 =FFFFFF24                  v_bg2screenposy_dup:	equ $FFFFFF24	; 2 bytes
00000000 =FFFFFF28                  v_bg3screenposx_dup:	equ $FFFFFF28	; 2 bytes
00000000 =FFFFFF2C                  v_bg3screenposy_dup:	equ $FFFFFF2C	; 2 bytes
00000000 =FFFFFF30                  v_fg_scroll_flags_dup:	equ $FFFFFF30
00000000 =FFFFFF32                  v_bg1_scroll_flags_dup:	equ $FFFFFF32
00000000 =FFFFFF34                  v_bg2_scroll_flags_dup:	equ $FFFFFF34
00000000 =FFFFFF36                  v_bg3_scroll_flags_dup:	equ $FFFFFF36
00000000                            
00000000 =FFFFFF80                  v_levseldelay:	equ $FFFFFF80	; level select - time until change when up/down is held (2 bytes)
00000000 =FFFFFF82                  v_levselitem:	equ $FFFFFF82	; level select - item selected (2 bytes)
00000000 =FFFFFF84                  v_levselsound:	equ $FFFFFF84	; level select - sound selected (2 bytes)
00000000 =FFFFFFC0                  v_scorecopy:	equ $FFFFFFC0	; score, duplicate (4 bytes)
00000000 =FFFFFFC0                  v_scorelife:	equ $FFFFFFC0	; points required for an extra life (4 bytes) (JP1 only)
00000000 =FFFFFFE0                  f_levselcheat:	equ $FFFFFFE0	; level select cheat flag
00000000 =FFFFFFE1                  f_slomocheat:	equ $FFFFFFE1	; slow motion & frame advance cheat flag
00000000 =FFFFFFE2                  f_debugcheat:	equ $FFFFFFE2	; debug mode cheat flag
00000000 =FFFFFFE3                  f_creditscheat:	equ $FFFFFFE3	; hidden credits & press start cheat flag
00000000 =FFFFFFE4                  v_title_dcount:	equ $FFFFFFE4	; number of times the d-pad is pressed on title screen (2 bytes)
00000000 =FFFFFFE6                  v_title_ccount:	equ $FFFFFFE6	; number of times C is pressed on title screen (2 bytes)
00000000                            
00000000 =FFFFFFF0                  f_demo:		equ $FFFFFFF0	; demo mode flag (0 = no; 1 = yes; $8001 = ending) (2 bytes)
00000000 =FFFFFFF2                  v_demonum:	equ $FFFFFFF2	; demo level number (not the same as the level number) (2 bytes)
00000000 =FFFFFFF4                  v_creditsnum:	equ $FFFFFFF4	; credits index number (2 bytes)
00000000 =FFFFFFF8                  v_megadrive:	equ $FFFFFFF8	; Megadrive machine type
00000000 =FFFFFFFA                  f_debugmode:	equ $FFFFFFFA	; debug mode flag (sometimes 2 bytes)
00000000 =FFFFFFFC                  v_init:		equ $FFFFFFFC	; 'init' text string (4 bytes)
00000000 =FFFFFFFC                  v_init:		equ $FFFFFFFC	; 'init' text string (4 bytes)
00000000                            		include	"Macros.asm"
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Align and pad
00000000                            ; input: length to align to, value to use as padding (default is 0)
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            align:	macro
00000000                            	if (narg=1)
00000000                            	dcb.b (\1-(*%\1))%\1,0
00000000                            	else
00000000                            	dcb.b (\1-(*%\1))%\1,\2
00000000                            	endc
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Set a VRAM address via the VDP control port.
00000000                            ; input: 16-bit VRAM address, control port (default is ($C00004).l)
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            locVRAM:	macro loc,controlport
00000000                            		if (narg=1)
00000000                            		move.l	#($40000000+((loc&$3FFF)<<16)+((loc&$C000)>>14)),(vdp_control_port).l
00000000                            		else
00000000                            		move.l	#($40000000+((loc&$3FFF)<<16)+((loc&$C000)>>14)),\controlport
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; DMA copy data from 68K (ROM/RAM) to the VRAM
00000000                            ; input: source, length, destination
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            writeVRAM:	macro source,length,destination
00000000                            		lea	(vdp_control_port).l,a5
00000000                            		move.l	#$94000000+(((length>>1)&$FF00)<<8)+$9300+((length>>1)&$FF),(a5)
00000000                            		move.l	#$96000000+(((source>>1)&$FF00)<<8)+$9500+((source>>1)&$FF),(a5)
00000000                            		move.w	#$9700+((((source>>1)&$FF0000)>>16)&$7F),(a5)
00000000                            		move.w	#$4000+(destination&$3FFF),(a5)
00000000                            		move.w	#$80+((destination&$C000)>>14),(v_vdp_buffer2).w
00000000                            		move.w	(v_vdp_buffer2).w,(a5)
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; DMA copy data from 68K (ROM/RAM) to the CRAM
00000000                            ; input: source, length, destination
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            writeCRAM:	macro source,length,destination
00000000                            		lea	(vdp_control_port).l,a5
00000000                            		move.l	#$94000000+(((length>>1)&$FF00)<<8)+$9300+((length>>1)&$FF),(a5)
00000000                            		move.l	#$96000000+(((source>>1)&$FF00)<<8)+$9500+((source>>1)&$FF),(a5)
00000000                            		move.w	#$9700+((((source>>1)&$FF0000)>>16)&$7F),(a5)
00000000                            		move.w	#$C000+(destination&$3FFF),(a5)
00000000                            		move.w	#$80+((destination&$C000)>>14),(v_vdp_buffer2).w
00000000                            		move.w	(v_vdp_buffer2).w,(a5)
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; DMA fill VRAM with a value
00000000                            ; input: value, length, destination
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            fillVRAM:	macro value,length,loc
00000000                            		lea	(vdp_control_port).l,a5
00000000                            		move.w	#$8F01,(a5)
00000000                            		move.l	#$94000000+((length&$FF00)<<8)+$9300+(length&$FF),(a5)
00000000                            		move.w	#$9780,(a5)
00000000                            		move.l	#$40000080+((loc&$3FFF)<<16)+((loc&$C000)>>14),(a5)
00000000                            		move.w	#value,(vdp_data_port).l
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Copy a tilemap from 68K (ROM/RAM) to the VRAM without using DMA
00000000                            ; input: source, destination, width [cells], height [cells]
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            copyTilemap:	macro source,destination,width,height
00000000                            		lea	(source).l,a1
00000000                            		locVRAM	\destination,d0
00000000                            		moveq	#width,d1
00000000                            		moveq	#height,d2
00000000                            		bsr.w	TilemapToVRAM
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; stop the Z80
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            stopZ80:	macro
00000000                            		move.w	#$100,(z80_bus_request).l
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; wait for Z80 to stop
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            waitZ80:	macro
00000000                            	@wait:	btst	#0,(z80_bus_request).l
00000000                            		bne.s	@wait
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; reset the Z80
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            resetZ80:	macro
00000000                            		move.w	#$100,(z80_reset).l
00000000                            		endm
00000000                            
00000000                            resetZ80a:	macro
00000000                            		move.w	#0,(z80_reset).l
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; start the Z80
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            startZ80:	macro
00000000                            		move.w	#0,(z80_bus_request).l
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; disable interrupts
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            disable_ints:	macro
00000000                            		move	#$2700,sr
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; enable interrupts
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            enable_ints:	macro
00000000                            		move	#$2300,sr
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; long conditional jumps
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            jhi:		macro loc
00000000                            		bls.s	@nojump
00000000                            		jmp	loc
00000000                            	@nojump:
00000000                            		endm
00000000                            
00000000                            jcc:		macro loc
00000000                            		bcs.s	@nojump
00000000                            		jmp	loc
00000000                            	@nojump:
00000000                            		endm
00000000                            
00000000                            jhs:		macro loc
00000000                            		jcc	loc
00000000                            		endm
00000000                            
00000000                            jls:		macro loc
00000000                            		bhi.s	@nojump
00000000                            		jmp	loc
00000000                            	@nojump:
00000000                            		endm
00000000                            
00000000                            jcs:		macro loc
00000000                            		bcc.s	@nojump
00000000                            		jmp	loc
00000000                            	@nojump:
00000000                            		endm
00000000                            
00000000                            jlo:		macro loc
00000000                            		jcs	loc
00000000                            		endm
00000000                            
00000000                            jeq:		macro loc
00000000                            		bne.s	@nojump
00000000                            		jmp	loc
00000000                            	@nojump:
00000000                            		endm
00000000                            
00000000                            jne:		macro loc
00000000                            		beq.s	@nojump
00000000                            		jmp	loc
00000000                            	@nojump:
00000000                            		endm
00000000                            
00000000                            jgt:		macro loc
00000000                            		ble.s	@nojump
00000000                            		jmp	loc
00000000                            	@nojump:
00000000                            		endm
00000000                            
00000000                            jge:		macro loc
00000000                            		blt.s	@nojump
00000000                            		jmp	loc
00000000                            	@nojump:
00000000                            		endm
00000000                            
00000000                            jle:		macro loc
00000000                            		bgt.s	@nojump
00000000                            		jmp	loc
00000000                            	@nojump:
00000000                            		endm
00000000                            
00000000                            jlt:		macro loc
00000000                            		bge.s	@nojump
00000000                            		jmp	loc
00000000                            	@nojump:
00000000                            		endm
00000000                            
00000000                            jpl:		macro loc
00000000                            		bmi.s	@nojump
00000000                            		jmp	loc
00000000                            	@nojump:
00000000                            		endm
00000000                            
00000000                            jmi:		macro loc
00000000                            		bpl.s	@nojump
00000000                            		jmp	loc
00000000                            	@nojump:
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; check if object moves out of range
00000000                            ; input: location to jump to if out of range, x-axis pos (obX(a0) by default)
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            out_of_range:	macro exit,pos
00000000                            		if (narg=2)
00000000                            		move.w	pos,d0		; get object position (if specified as not obX)
00000000                            		else
00000000                            		move.w	obX(a0),d0	; get object position
00000000                            		endc
00000000                            		andi.w	#$FF80,d0	; round down to nearest $80
00000000                            		move.w	(v_screenposx).w,d1 ; get screen position
00000000                            		subi.w	#128,d1
00000000                            		andi.w	#$FF80,d1
00000000                            		sub.w	d1,d0		; approx distance between object and screen
00000000                            		cmpi.w	#128+320+192,d0
00000000                            		bhi.\0	exit
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; bankswitch between SRAM and ROM
00000000                            ; (remember to enable SRAM in the header first!)
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            gotoSRAM:	macro
00000000                            		move.b	#1,($A130F1).l
00000000                            		endm
00000000                            
00000000                            gotoROM:	macro
00000000                            		move.b	#0,($A130F1).l
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; compare the size of an index with ZoneCount constant
00000000                            ; (should be used immediately after the index)
00000000                            ; input: index address, element size
00000000                            ; ---------------------------------------------------------------------------
00000000                            ;
00000000                            ;zonewarning:	macro loc,elementsize
00000000                            ;	@end:
00000000                            ;		if (@end-loc)-(ZoneCount*elementsize)<>0
00000000                            ;		inform 1,"Size of \loc ($%h) does not match ZoneCount ($\#ZoneCount).",(@end-loc)/elementsize
00000000                            ;		endc
00000000                            ;		endm
00000000                            ;		endm
00000000                            
00000000 =00000000                  EnableSRAM:				= 0	; change to 1 to enable SRAM
00000000 =00000001                  BackupSRAM:				= 1
00000000 =00000003                  AddressSRAM:			= 3	; 0 = odd+even; 2 = even only; 3 = odd only
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            StartOfROM:
00000000 00FF FE00                  Vectors:	dc.l v_systemstack&$FFFFFF	; Initial stack pointer value
00000004 0000 0000                  		dc.l EntryPoint			; Start of program
00000008 0000 0000                  		dc.l BusError			; Bus error
0000000C 0000 0000                  		dc.l AddressError		; Address error (4)
00000010 0000 0000                  		dc.l IllegalInstr		; Illegal instruction
00000014 0000 0000                  		dc.l ZeroDivide			; Division by zero
00000018 0000 0000                  		dc.l ChkInstr			; CHK exception
0000001C 0000 0000                  		dc.l TrapvInstr			; TRAPV exception (8)
00000020 0000 0000                  		dc.l PrivilegeViol		; Privilege violation
00000024 0000 0000                  		dc.l Trace				; TRACE exception
00000028 0000 0000                  		dc.l Line1010Emu		; Line-A emulator
0000002C 0000 0000                  		dc.l Line1111Emu		; Line-F emulator (12)
00000030 0000 0000                  		dc.l ErrorExcept		; Unused (reserved)
00000034 0000 0000                  		dc.l ErrorExcept		; Unused (reserved)
00000038 0000 0000                  		dc.l ErrorExcept		; Unused (reserved)
0000003C 0000 0000                  		dc.l ErrorExcept		; Unused (reserved) (16)
00000040 0000 0000                  		dc.l ErrorExcept		; Unused (reserved)
00000044 0000 0000                  		dc.l ErrorExcept		; Unused (reserved)
00000048 0000 0000                  		dc.l ErrorExcept		; Unused (reserved)
0000004C 0000 0000                  		dc.l ErrorExcept		; Unused (reserved) (20)
00000050 0000 0000                  		dc.l ErrorExcept		; Unused (reserved)
00000054 0000 0000                  		dc.l ErrorExcept		; Unused (reserved)
00000058 0000 0000                  		dc.l ErrorExcept		; Unused (reserved)
0000005C 0000 0000                  		dc.l ErrorExcept		; Unused (reserved) (24)
00000060 0000 0000                  		dc.l ErrorExcept		; Spurious exception
00000064 0000 0000                  		dc.l ErrorTrap			; IRQ level 1
00000068 0000 0000                  		dc.l ErrorTrap			; IRQ level 2
0000006C 0000 0000                  		dc.l ErrorTrap			; IRQ level 3 (28)
00000070 0000 0000                  		dc.l HBlank				; IRQ level 4 (horizontal retrace interrupt)
00000074 0000 0000                  		dc.l ErrorTrap			; IRQ level 5
00000078 0000 0000                  		dc.l VBlank				; IRQ level 6 (vertical retrace interrupt)
0000007C 0000 0000                  		dc.l ErrorTrap			; IRQ level 7 (32)
00000080 0000 0000                  		dc.l ErrorTrap			; TRAP #00 exception
00000084 0000 0000                  		dc.l ErrorTrap			; TRAP #01 exception
00000088 0000 0000                  		dc.l ErrorTrap			; TRAP #02 exception
0000008C 0000 0000                  		dc.l ErrorTrap			; TRAP #03 exception (36)
00000090 0000 0000                  		dc.l ErrorTrap			; TRAP #04 exception
00000094 0000 0000                  		dc.l ErrorTrap			; TRAP #05 exception
00000098 0000 0000                  		dc.l ErrorTrap			; TRAP #06 exception
0000009C 0000 0000                  		dc.l ErrorTrap			; TRAP #07 exception (40)
000000A0 0000 0000                  		dc.l ErrorTrap			; TRAP #08 exception
000000A4 0000 0000                  		dc.l ErrorTrap			; TRAP #09 exception
000000A8 0000 0000                  		dc.l ErrorTrap			; TRAP #10 exception
000000AC 0000 0000                  		dc.l ErrorTrap			; TRAP #11 exception (44)
000000B0 0000 0000                  		dc.l ErrorTrap			; TRAP #12 exception
000000B4 0000 0000                  		dc.l ErrorTrap			; TRAP #13 exception
000000B8 0000 0000                  		dc.l ErrorTrap			; TRAP #14 exception
000000BC 0000 0000                  		dc.l ErrorTrap			; TRAP #15 exception (48)
000000C0 0000 0000                  		dc.l ErrorTrap			; Unused (reserved)
000000C4 0000 0000                  		dc.l ErrorTrap			; Unused (reserved)
000000C8 0000 0000                  		dc.l ErrorTrap			; Unused (reserved)
000000CC 0000 0000                  		dc.l ErrorTrap			; Unused (reserved)
000000D0 0000 0000                  		dc.l ErrorTrap			; Unused (reserved)
000000D4 0000 0000                  		dc.l ErrorTrap			; Unused (reserved)
000000D8 0000 0000                  		dc.l ErrorTrap			; Unused (reserved)
000000DC 0000 0000                  		dc.l ErrorTrap			; Unused (reserved)
000000E0 0000 0000                  		dc.l ErrorTrap			; Unused (reserved)
000000E4 0000 0000                  		dc.l ErrorTrap			; Unused (reserved)
000000E8 0000 0000                  		dc.l ErrorTrap			; Unused (reserved)
000000EC 0000 0000                  		dc.l ErrorTrap			; Unused (reserved)
000000F0 0000 0000                  		dc.l ErrorTrap			; Unused (reserved)
000000F4 0000 0000                  		dc.l ErrorTrap			; Unused (reserved)
000000F8 0000 0000                  		dc.l ErrorTrap			; Unused (reserved)
000000FC 0000 0000                  		dc.l ErrorTrap			; Unused (reserved)
00000100                            
00000100 5345 4741 2047 454E 4553+  Header:			dc.b	"SEGA GENESIS    "
00000110 2843 2953 4547 4120 5858+  Copyright:		dc.b	"(C)SEGA XXXX.XXX"
00000120 5357 4E2D 3030 3120 4F4E+  Domestic_Name:	dc.b	"SWN-001 ON THE FUCKING SEGA MEGA DRIVE          "
00000150 5357 4E2D 3030 3120 4F4E+  Overseas_Name:	dc.b	"SWN-001 ON THE FUCKING SEGA MEGA DRIVE          "
00000180 474D 204D 4B2D 3030 3030+  Serial_Number:	dc.b	"GM MK-0000 -00"
0000018E 0000                       Checksum:		dc.w	0
00000190 4A20 2020 2020 2020 2020+  Input:			dc.b	"J               "
000001A0 0000 0000                  RomStartLoc:	dc.l	StartOfROM
000001A4 0000 0000                  RomEndLoc:	dc.l EndOfRom-1		; End address of ROM
000001A8 00FF 0000                  		dc.l $FF0000		; Start address of RAM
000001AC 00FF FFFF                  		dc.l $FFFFFF		; End address of RAM
000001B0 2020 2020                  		dc.l $20202020
000001B4 2020 2020                  		dc.l $20202020		; SRAM start ($200001)
000001B8 2020 2020                  		dc.l $20202020		; SRAM end ($20xxxx)
000001BC 2020 2020 2020 2020 2020+  		dc.b "                                                    " ; Notes (unused, anything can be put in this space, but it has to be 52 bytes.)
000001F0 4A55 4520 2020 2020 2020+  		dc.b "JUE             " ; Region (Country code)
00000200                            SRAMSupport:
00000200 2020                       		CartRAM_Info:	dc.b	"  "
00000202 2020                       		CartRAM_Type:	dc.w	%10000000100000
00000204 2020 2020                  		CartRAMStartLoc:dc.l	$20202020							; SRAM start ($200000)
00000208 2020 2020                  		CartRAMEndLoc:	dc.l	$20202020							; SRAM end ($20xxxx)
0000020C 2020 2020 2020 2020 2020+  Modem_Info:		dc.b	"                                                    "
00000240 4A55 4520 2020 2020 2020+  Country_Code:	dc.b	"JUE             "
00000250                            EndOfHeader:
00000250 0000                       		dc.w	0	; to make bizhawk work. stupid-ass eagle
00000252                            
00000252                            ; ---------------------------------------------------------------------------
00000252                            ; Init code from Sonic 1
00000252                            ; ---------------------------------------------------------------------------
00000252                            
00000252                            		include "_Includes/Initialization.asm"
00000252                            ; ===========================================================================
00000252                            ; Crash/Freeze the 68000. Unlike Sonic 2, Sonic 1 uses the 68000 for playing music, so it stops too
00000252                            
00000252                            ErrorTrap:
00000252 4E71                       		nop	
00000254 4E71                       		nop	
00000256 60FA                       		bra.s	ErrorTrap
00000258                            ; ===========================================================================
00000258                            
00000258                            EntryPoint:
00000258 4AB9 00A1 0008             		tst.l	(z80_port_1_control).l ; test port A & B control registers
0000025E 6600                       		bne.s	PortA_Ok
00000260 4A79 00A1 000C             		tst.w	(z80_expansion_control).l ; test port C control register
00000266                            
00000266                            PortA_Ok:
00000266 6600                       		bne.s	SkipSetup ; Skip the VDP and Z80 setup code if port A, B or C is ok...?
00000268 4BFA 0000                  		lea	SetupValues(pc),a5	; Load setup values array address.
0000026C 4C9D 00E0                  		movem.w	(a5)+,d5-d7
00000270 4CDD 1F00                  		movem.l	(a5)+,a0-a4
00000274 1029 EF01                  		move.b	-$10FF(a1),d0	; get hardware version (from $A10001)
00000278 0200 000F                  		andi.b	#$F,d0
0000027C 6700                       		beq.s	SkipSecurity	; If the console has no TMSS, skip the security stuff.
0000027E 237C 5345 4741 2F00        		move.l	#'SEGA',$2F00(a1) ; move "SEGA" to TMSS register ($A14000)
00000286                            
00000286                            SkipSecurity:
00000286 3014                       		move.w	(a4),d0	; clear write-pending flag in VDP to prevent issues if the 68k has been reset in the middle of writing a command long word to the VDP.
00000288 7000                       		moveq	#0,d0	; clear d0
0000028A 2C40                       		movea.l	d0,a6	; clear a6
0000028C 4E66                       		move.l	a6,usp	; set usp to $0
0000028E                            
0000028E 7217                       		moveq	#$17,d1
00000290                            VDPInitLoop:
00000290 1A1D                       		move.b	(a5)+,d5	; add $8000 to value
00000292 3885                       		move.w	d5,(a4)		; move value to	VDP register
00000294 DA47                       		add.w	d7,d5		; next register
00000296 51C9 FFF8                  		dbf	d1,VDPInitLoop
0000029A                            		
0000029A 289D                       		move.l	(a5)+,(a4)
0000029C 3680                       		move.w	d0,(a3)		; clear	the VRAM
0000029E 3287                       		move.w	d7,(a1)		; stop the Z80
000002A0 3487                       		move.w	d7,(a2)		; reset	the Z80
000002A2                            
000002A2                            WaitForZ80:
000002A2 0111                       		btst	d0,(a1)		; has the Z80 stopped?
000002A4 66FC                       		bne.s	WaitForZ80	; if not, branch
000002A6                            
000002A6 7425                       		moveq	#$25,d2
000002A8                            Z80InitLoop:
000002A8 10DD                       		move.b	(a5)+,(a0)+
000002AA 51CA FFFC                  		dbf	d2,Z80InitLoop
000002AE                            		
000002AE 3480                       		move.w	d0,(a2)
000002B0 3280                       		move.w	d0,(a1)		; start	the Z80
000002B2 3487                       		move.w	d7,(a2)		; reset	the Z80
000002B4                            
000002B4                            ClrRAMLoop:
000002B4 2D00                       		move.l	d0,-(a6)	; clear 4 bytes of RAM
000002B6 51CE FFFC                  		dbf	d6,ClrRAMLoop	; repeat until the entire RAM is clear
000002BA 289D                       		move.l	(a5)+,(a4)	; set VDP display mode and increment mode
000002BC 289D                       		move.l	(a5)+,(a4)	; set VDP to CRAM write
000002BE                            
000002BE 761F                       		moveq	#$1F,d3	; set repeat times
000002C0                            ClrCRAMLoop:
000002C0 2680                       		move.l	d0,(a3)	; clear 2 palettes
000002C2 51CB FFFC                  		dbf	d3,ClrCRAMLoop	; repeat until the entire CRAM is clear
000002C6 289D                       		move.l	(a5)+,(a4)	; set VDP to VSRAM write
000002C8                            
000002C8 7813                       		moveq	#$13,d4
000002CA                            ClrVSRAMLoop:
000002CA 2680                       		move.l	d0,(a3)	; clear 4 bytes of VSRAM.
000002CC 51CC FFFC                  		dbf	d4,ClrVSRAMLoop	; repeat until the entire VSRAM is clear
000002D0 7A03                       		moveq	#3,d5
000002D2                            
000002D2                            PSGInitLoop:
000002D2 175D 0011                  		move.b	(a5)+,$11(a3)	; reset	the PSG
000002D6 51CD FFFA                  		dbf	d5,PSGInitLoop	; repeat for other channels
000002DA 3480                       		move.w	d0,(a2)
000002DC 4CD6 7FFF                  		movem.l	(a6),d0-a6	; clear all registers
000002E0 46FC 2700                  		disable_ints
000002E4                            
000002E4                            SkipSetup:
000002E4 6000                       		bra.s	GameProgram	; begin game
000002E6                            
000002E6                            ; ===========================================================================
000002E6 8000                       SetupValues:	dc.w $8000		; VDP register start number
000002E8 3FFF                       		dc.w $3FFF		; size of RAM/4
000002EA 0100                       		dc.w $100		; VDP register diff
000002EC                            
000002EC 00A0 0000                  		dc.l z80_ram		; start	of Z80 RAM
000002F0 00A1 1100                  		dc.l z80_bus_request	; Z80 bus request
000002F4 00A1 1200                  		dc.l z80_reset		; Z80 reset
000002F8 00C0 0000                  		dc.l vdp_data_port	; VDP data
000002FC 00C0 0004                  		dc.l vdp_control_port	; VDP control
00000300                            
00000300 04                         		dc.b 4			; VDP $80 - 8-colour mode
00000301 14                         		dc.b $14		; VDP $81 - Megadrive mode, DMA enable
00000302 30                         		dc.b ($C000>>10)	; VDP $82 - foreground nametable address
00000303 3C                         		dc.b ($F000>>10)	; VDP $83 - window nametable address
00000304 07                         		dc.b ($E000>>13)	; VDP $84 - background nametable address
00000305 6C                         		dc.b ($D800>>9)		; VDP $85 - sprite table address
00000306 00                         		dc.b 0			; VDP $86 - unused
00000307 00                         		dc.b 0			; VDP $87 - background colour
00000308 00                         		dc.b 0			; VDP $88 - unused
00000309 00                         		dc.b 0			; VDP $89 - unused
0000030A FF                         		dc.b 255		; VDP $8A - HBlank register
0000030B 00                         		dc.b 0			; VDP $8B - full screen scroll
0000030C 81                         		dc.b $81		; VDP $8C - 40 cell display
0000030D 37                         		dc.b ($DC00>>10)	; VDP $8D - hscroll table address
0000030E 00                         		dc.b 0			; VDP $8E - unused
0000030F 01                         		dc.b 1			; VDP $8F - VDP increment
00000310 01                         		dc.b 1			; VDP $90 - 64 cell hscroll size
00000311 00                         		dc.b 0			; VDP $91 - window h position
00000312 00                         		dc.b 0			; VDP $92 - window v position
00000313 FFFF                       		dc.w $FFFF		; VDP $93/94 - DMA length
00000315 0000                       		dc.w 0			; VDP $95/96 - DMA source
00000317 80                         		dc.b $80		; VDP $97 - DMA fill VRAM
00000318 4000 0080                  		dc.l $40000080		; VRAM address 0
0000031C                            
0000031C AF                         		dc.b $AF		; xor	a
0000031D 01D9 1F                    		dc.b $01, $D9, $1F	; ld	bc,1fd9h
00000320 1127 00                    		dc.b $11, $27, $00	; ld	de,0027h
00000323 2126 00                    		dc.b $21, $26, $00	; ld	hl,0026h
00000326 F9                         		dc.b $F9		; ld	sp,hl
00000327 77                         		dc.b $77		; ld	(hl),a
00000328 EDB0                       		dc.b $ED, $B0		; ldir
0000032A DDE1                       		dc.b $DD, $E1		; pop	ix
0000032C FDE1                       		dc.b $FD, $E1		; pop	iy
0000032E ED47                       		dc.b $ED, $47		; ld	i,a
00000330 ED4F                       		dc.b $ED, $4F		; ld	r,a
00000332 D1                         		dc.b $D1		; pop	de
00000333 E1                         		dc.b $E1		; pop	hl
00000334 F1                         		dc.b $F1		; pop	af
00000335 08                         		dc.b $08		; ex	af,af'
00000336 D9                         		dc.b $D9		; exx
00000337 C1                         		dc.b $C1		; pop	bc
00000338 D1                         		dc.b $D1		; pop	de
00000339 E1                         		dc.b $E1		; pop	hl
0000033A F1                         		dc.b $F1		; pop	af
0000033B F9                         		dc.b $F9		; ld	sp,hl
0000033C F3                         		dc.b $F3		; di
0000033D ED56                       		dc.b $ED, $56		; im1
0000033F 36E9                       		dc.b $36, $E9		; ld	(hl),e9h
00000341 E9                         		dc.b $E9		; jp	(hl)
00000342                            
00000342 8104                       		dc.w $8104		; VDP display mode
00000344 8F02                       		dc.w $8F02		; VDP increment
00000346 C000 0000                  		dc.l $C0000000		; CRAM write mode
0000034A 4000 0010                  		dc.l $40000010		; VSRAM address 0
0000034E                            
0000034E 9FBF DFFF                  		dc.b $9F, $BF, $DF, $FF	; values for PSG channel volumes
00000352                            ; ===========================================================================
00000352                            
00000352                            GameProgram:
00000352 4A79 00C0 0004             		tst.w	(vdp_control_port).l
00000358 0839 0006 00A1 000D        		btst	#6,($A1000D).l
00000360 6700                       		beq.s	CheckSumCheck
00000362 0CB8 696E 6974 FFFC        		cmpi.l	#'init',(v_init).w ; has checksum routine already run?
0000036A 6700 0000                  		beq.w	GameInit	; if yes, branch
0000036E                            
0000036E                            CheckSumCheck:
0000036E 207C 0000 0250             		movea.l	#EndOfHeader,a0	; start	checking bytes after the header	($200)
00000374 227C 0000 01A4             		movea.l	#RomEndLoc,a1	; stop at end of ROM
0000037A 2011                       		move.l	(a1),d0
0000037C 7200                       		moveq	#0,d1
0000037E                            
0000037E                            	@loop:
0000037E D258                       		add.w	(a0)+,d1
00000380 B088                       		cmp.l	a0,d0
00000382 64FA                       		bhs.s	@loop
00000384 227C 0000 018E             		movea.l	#Checksum,a1	; read the checksum
0000038A B251                       		cmp.w	(a1),d1		; compare checksum in header to ROM
0000038C 6600 0000                  		bne.w	CheckSumError	; if they don't match, branch
00000390                            
00000390                            	CheckSumOk:
00000390 4DF8 FE00                  		lea	($FFFFFE00).w,a6
00000394 7E00                       		moveq	#0,d7
00000396 3C3C 007F                  		move.w	#$7F,d6
0000039A                            	@clearRAM:
0000039A 2CC7                       		move.l	d7,(a6)+
0000039C 51CE FFFC                  		dbf	d6,@clearRAM	; clear RAM ($FE00-$FFFF)
000003A0                            
000003A0 1039 00A1 0001             		move.b	(z80_version).l,d0
000003A6 0200 00C0                  		andi.b	#$C0,d0
000003AA 11C0 FFF8                  		move.b	d0,(v_megadrive).w ; get region setting
000003AE 21FC 696E 6974 FFFC        		move.l	#'init',(v_init).w ; set flag so checksum won't run again
000003B6                            
000003B6                            GameInit:
000003B6 4DF9 00FF 0000             		lea	($FF0000).l,a6
000003BC 7E00                       		moveq	#0,d7
000003BE 3C3C 3F7F                  		move.w	#$3F7F,d6
000003C2                            	@clearRAM:
000003C2 2CC7                       		move.l	d7,(a6)+
000003C4 51CE FFFC                  		dbf	d6,@clearRAM	; clear RAM ($0000-$FDFF)
000003C8                            
000003C8 6100 0000                  		bsr.w	VDPSetupGame
000003CC 6100 0000                  		bsr.w	SoundDriverLoad
000003D0 6100 0000                  		bsr.w	JoypadInit
000003D4 11FC 0000 F600             		move.b	#id_Sega,(v_gamemode).w ; set Game Mode to Sega Screen
000003DA                            
000003DA                            MainGameLoop:
000003DA 1038 F600                  		move.b	(v_gamemode).w,d0 ; load Game Mode
000003DE 0240 001C                  		andi.w	#$1C,d0	; limit Game Mode value to $1C max (change to a maximum of 7C to add more game modes)
000003E2 4EBB 0000                  		jsr	GameModeArray(pc,d0.w) ; jump to apt location in ROM
000003E6 60F2                       		bra.s	MainGameLoop	; loop indefinitely
000003E8                            ; ===========================================================================
000003E8                            ; ---------------------------------------------------------------------------
000003E8                            ; Main game mode array
000003E8                            ; ---------------------------------------------------------------------------
000003E8                            
000003E8                            GameModeArray:
000003E8                            
000003E8 6000 0000                  ptr_GM_Sega:	bra.w	GM_Sega		; Sega Screen ($00)
000003EC                            
000003EC 6000 0000                  ptr_GM_Title:	bra.w	GM_Title	; Title	Screen ($04)
000003F0                            
000003F0 6000 0000                  ptr_GM_Level:	bra.w	GM_Level	; Level Mode ($08)
000003F4                            
000003F4 4E75                       		rts	
000003F6                            
000003F6                            GM_Sega:
000003F6                            GM_Title:
000003F6                            GM_Level:
000003F6 4E75                       	rts
000003F6 4E75                       	rts
000003F8                            
000003F8                            ; ---------------------------------------------------------------------------
000003F8                            ; Interrupt code from Sonic 1
000003F8                            ; ---------------------------------------------------------------------------
000003F8                            
000003F8                            		include "_Includes/Interrupts.asm"
000003F8                            ; ---------------------------------------------------------------------------
000003F8                            ; Vertical interrupt
000003F8                            ; ---------------------------------------------------------------------------
000003F8                            
000003F8                            VBlank:
000003F8 48E7 FFFE                  		movem.l	d0-a6,-(sp)
000003FC 4A38 F62A                  		tst.b	(v_vbla_routine).w
00000400 6700                       		beq.s	VBla_00
00000402 3039 00C0 0004             		move.w	(vdp_control_port).l,d0
00000408 23FC 4000 0010 00C0 0004   		move.l	#$40000010,(vdp_control_port).l
00000412 23F8 F616 00C0 0000        		move.l	(v_scrposy_vdp).w,(vdp_data_port).l ; send screen y-axis pos. to VSRAM
0000041A 0838 0006 FFF8             		btst	#6,(v_megadrive).w ; is Megadrive PAL?
00000420 6700                       		beq.s	@notPAL		; if not, branch
00000422                            
00000422 303C 0700                  		move.w	#$700,d0
00000426                            	@waitPAL:
00000426 51C8 FFFE                  		dbf	d0,@waitPAL ; wait here in a loop doing nothing for a while...
0000042A                            
0000042A                            	@notPAL:
0000042A 1038 F62A                  		move.b	(v_vbla_routine).w,d0
0000042E 11FC 0000 F62A             		move.b	#0,(v_vbla_routine).w
00000434 31FC 0001 F644             		move.w	#1,(f_hbla_pal).w
0000043A 0240 003E                  		andi.w	#$3E,d0
0000043E 303B 0000                  		move.w	VBla_Index(pc,d0.w),d0
00000442 4EBB 0000                  		jsr	VBla_Index(pc,d0.w)
00000446                            
00000446                            VBla_Music:
00000446 4EB9 0000 0000             		jsr	(UpdateMusic).l
0000044C                            
0000044C                            VBla_Exit:
0000044C 52B8 FE0C                  		addq.l	#1,(v_vbla_count).w
00000450 4CDF 7FFF                  		movem.l	(sp)+,d0-a6
00000454 4E73                       		rte	
00000456                            ; ===========================================================================
00000456 0000 0000                  VBla_Index:	dc.w VBla_00-VBla_Index, VBla_02-VBla_Index
0000045A 0000 0000                  		dc.w VBla_04-VBla_Index, VBla_06-VBla_Index
0000045E 0000 0000                  		dc.w VBla_08-VBla_Index, VBla_0A-VBla_Index
00000462 0000 0000                  		dc.w VBla_0C-VBla_Index, VBla_0E-VBla_Index
00000466 0000 0000                  		dc.w VBla_10-VBla_Index, VBla_12-VBla_Index
0000046A 0000 0000                  		dc.w VBla_14-VBla_Index, VBla_16-VBla_Index
0000046E 0000                       		dc.w VBla_0C-VBla_Index
00000470                            ; ===========================================================================
00000470                            
00000470                            VBla_00:
00000470 0C38 0000 F600             		cmpi.b	#$80+id_Level,(v_gamemode).w
00000476 6700                       		beq.s	@islevel
00000478 0C38 0000 F600             		cmpi.b	#id_Level,(v_gamemode).w ; is game on a level?
0000047E 6600 FFC6                  		bne.w	VBla_Music	; if not, branch
00000482                            
00000482                            	@islevel:
00000482 0C38 0000 FE10             		cmpi.b	#id_LZ,(v_zone).w ; is level LZ ?
00000488 6600 FFBC                  		bne.w	VBla_Music	; if not, branch
0000048C                            
0000048C 3039 00C0 0004             		move.w	(vdp_control_port).l,d0
00000492 0838 0006 FFF8             		btst	#6,(v_megadrive).w ; is Megadrive PAL?
00000498 6700                       		beq.s	@notPAL		; if not, branch
0000049A                            
0000049A 303C 0700                  		move.w	#$700,d0
0000049E                            	@waitPAL:
0000049E 51C8 FFFE                  		dbf	d0,@waitPAL
000004A2                            
000004A2                            	@notPAL:
000004A2 31FC 0001 F644             		move.w	#1,(f_hbla_pal).w ; set HBlank flag
000004A8 33FC 0100 00A1 1100        		stopZ80
000004B0 0839 0000 00A1 1100 66F6   		waitZ80
000004BA 4A38 F64E                  		tst.b	(f_wtr_state).w	; is water above top of screen?
000004BE 6600                       		bne.s	@waterabove 	; if yes, branch
000004C0                            
000004C0 4BF9 00C0 0004 2ABC 9400+  		writeCRAM	v_pal_dry,$80,0
000004E4 6000                       		bra.s	@waterbelow
000004E6                            
000004E6                            @waterabove:
000004E6 4BF9 00C0 0004 2ABC 9400+  		writeCRAM	v_pal_water,$80,0
0000050A                            
0000050A                            	@waterbelow:
0000050A 3AB8 F624                  		move.w	(v_hbla_hreg).w,(a5)
0000050E 33FC 0000 00A1 1100        		startZ80
00000516 6000 FF2E                  		bra.w	VBla_Music
0000051A                            ; ===========================================================================
0000051A                            
0000051A                            VBla_02:
0000051A 6100 0000                  		bsr.w	sub_106E
0000051E                            
0000051E                            VBla_14:
0000051E 4A78 F614                  		tst.w	(v_demolength).w
00000522 6700 0000                  		beq.w	@end
00000526 5378 F614                  		subq.w	#1,(v_demolength).w
0000052A                            
0000052A                            	@end:
0000052A 4E75                       		rts	
0000052C                            ; ===========================================================================
0000052C                            
0000052C                            VBla_04:
0000052C 6100 0000                  		bsr.w	sub_106E
00000530 6100 0000                  		bsr.w	LoadTilesAsYouMove_BGOnly
00000534 6100 0000                  		bsr.w	sub_1642
00000538 4A78 F614                  		tst.w	(v_demolength).w
0000053C 6700 0000                  		beq.w	@end
00000540 5378 F614                  		subq.w	#1,(v_demolength).w
00000544                            
00000544                            	@end:
00000544 4E75                       		rts	
00000546                            ; ===========================================================================
00000546                            
00000546                            VBla_06:
00000546 6100 0000                  		bsr.w	sub_106E
0000054A 4E75                       		rts	
0000054C                            ; ===========================================================================
0000054C                            
0000054C                            VBla_10:
0000054C 0C38 0000 F600             		cmpi.b	#id_Special,(v_gamemode).w ; is game on special stage?
00000552 6700 0000                  		beq.w	VBla_0A		; if yes, branch
00000556                            
00000556                            VBla_08:
00000556 33FC 0100 00A1 1100        		stopZ80
0000055E 0839 0000 00A1 1100 66F6   		waitZ80
00000568 6100 0000                  		bsr.w	ReadJoypads
0000056C 4A38 F64E                  		tst.b	(f_wtr_state).w
00000570 6600                       		bne.s	@waterabove
00000572                            
00000572 4BF9 00C0 0004 2ABC 9400+  		writeCRAM	v_pal_dry,$80,0
00000596 6000                       		bra.s	@waterbelow
00000598                            
00000598                            @waterabove:
00000598 4BF9 00C0 0004 2ABC 9400+  		writeCRAM	v_pal_water,$80,0
000005BC                            
000005BC                            	@waterbelow:
000005BC 3AB8 F624                  		move.w	(v_hbla_hreg).w,(a5)
000005C0                            
000005C0 4BF9 00C0 0004 2ABC 9401+  		writeVRAM	v_hscrolltablebuffer,$380,vram_hscroll
000005E4 4BF9 00C0 0004 2ABC 9401+  		writeVRAM	v_spritetablebuffer,$280,vram_sprites
00000608 4A38 F767                  		tst.b	(f_sonframechg).w ; has Sonic's sprite changed?
0000060C 6700                       		beq.s	@nochg		; if not, branch
0000060E                            
0000060E 4BF9 00C0 0004 2ABC 9401+  		writeVRAM	v_sgfx_buffer,$2E0,vram_sonic ; load new Sonic gfx
00000632 11FC 0000 F767             		move.b	#0,(f_sonframechg).w
00000638                            
00000638                            	@nochg:
00000638 33FC 0000 00A1 1100        		startZ80
00000640 4CF8 00FF F700             		movem.l	(v_screenposx).w,d0-d7
00000646 48F8 00FF FF10             		movem.l	d0-d7,(v_screenposx_dup).w
0000064C 4CF8 0003 F754             		movem.l	(v_fg_scroll_flags).w,d0-d1
00000652 48F8 0003 FF30             		movem.l	d0-d1,(v_fg_scroll_flags_dup).w
00000658 0C38 0060 F625             		cmpi.b	#96,(v_hbla_line).w
0000065E 6400                       		bhs.s	Demo_Time
00000660 11FC 0001 F64F             		move.b	#1,($FFFFF64F).w
00000666 588F                       		addq.l	#4,sp
00000668 6000 FDE2                  		bra.w	VBla_Exit
0000066C                            
0000066C                            ; ---------------------------------------------------------------------------
0000066C                            ; Subroutine to	run a demo for an amount of time
0000066C                            ; ---------------------------------------------------------------------------
0000066C                            
0000066C                            ; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
0000066C                            
0000066C                            
0000066C                            Demo_Time:
0000066C 6100 0000                  		bsr.w	LoadTilesAsYouMove
00000670 4EB9 0000 0000             		jsr	(AnimateLevelGfx).l
00000676 4EB9 0000 0000             		jsr	(HUD_Update).l
0000067C 6100 0000                  		bsr.w	ProcessDPLC2
00000680 4A78 F614                  		tst.w	(v_demolength).w ; is there time left on the demo?
00000684 6700 0000                  		beq.w	@end		; if not, branch
00000688 5378 F614                  		subq.w	#1,(v_demolength).w ; subtract 1 from time left
0000068C                            
0000068C                            	@end:
0000068C 4E75                       		rts	
0000068E                            ; End of function Demo_Time
0000068E                            
0000068E                            ; ===========================================================================
0000068E                            
0000068E                            VBla_0A:
0000068E 33FC 0100 00A1 1100        		stopZ80
00000696 0839 0000 00A1 1100 66F6   		waitZ80
000006A0 6100 0000                  		bsr.w	ReadJoypads
000006A4 4BF9 00C0 0004 2ABC 9400+  		writeCRAM	v_pal_dry,$80,0
000006C8 4BF9 00C0 0004 2ABC 9401+  		writeVRAM	v_spritetablebuffer,$280,vram_sprites
000006EC 4BF9 00C0 0004 2ABC 9401+  		writeVRAM	v_hscrolltablebuffer,$380,vram_hscroll
00000710 33FC 0000 00A1 1100        		startZ80
00000718 6100 0000                  		bsr.w	PalCycle_SS
0000071C 4A38 F767                  		tst.b	(f_sonframechg).w ; has Sonic's sprite changed?
00000720 6700                       		beq.s	@nochg		; if not, branch
00000722                            
00000722 4BF9 00C0 0004 2ABC 9401+  		writeVRAM	v_sgfx_buffer,$2E0,vram_sonic ; load new Sonic gfx
00000746 11FC 0000 F767             		move.b	#0,(f_sonframechg).w
0000074C                            
0000074C                            	@nochg:
0000074C 4A78 F614                  		tst.w	(v_demolength).w	; is there time left on the demo?
00000750 6700 0000                  		beq.w	@end	; if not, return
00000754 5378 F614                  		subq.w	#1,(v_demolength).w	; subtract 1 from time left in demo
00000758                            
00000758                            	@end:
00000758 4E75                       		rts	
0000075A                            ; ===========================================================================
0000075A                            
0000075A                            VBla_0C:
0000075A 33FC 0100 00A1 1100        		stopZ80
00000762 0839 0000 00A1 1100 66F6   		waitZ80
0000076C 6100 0000                  		bsr.w	ReadJoypads
00000770 4A38 F64E                  		tst.b	(f_wtr_state).w
00000774 6600                       		bne.s	@waterabove
00000776                            
00000776 4BF9 00C0 0004 2ABC 9400+  		writeCRAM	v_pal_dry,$80,0
0000079A 6000                       		bra.s	@waterbelow
0000079C                            
0000079C                            @waterabove:
0000079C 4BF9 00C0 0004 2ABC 9400+  		writeCRAM	v_pal_water,$80,0
000007C0                            
000007C0                            	@waterbelow:
000007C0 3AB8 F624                  		move.w	(v_hbla_hreg).w,(a5)
000007C4 4BF9 00C0 0004 2ABC 9401+  		writeVRAM	v_hscrolltablebuffer,$380,vram_hscroll
000007E8 4BF9 00C0 0004 2ABC 9401+  		writeVRAM	v_spritetablebuffer,$280,vram_sprites
0000080C 4A38 F767                  		tst.b	(f_sonframechg).w
00000810 6700                       		beq.s	@nochg
00000812 4BF9 00C0 0004 2ABC 9401+  		writeVRAM	v_sgfx_buffer,$2E0,vram_sonic
00000836 11FC 0000 F767             		move.b	#0,(f_sonframechg).w
0000083C                            
0000083C                            	@nochg:
0000083C 33FC 0000 00A1 1100        		startZ80
00000844 4CF8 00FF F700             		movem.l	(v_screenposx).w,d0-d7
0000084A 48F8 00FF FF10             		movem.l	d0-d7,(v_screenposx_dup).w
00000850 4CF8 0003 F754             		movem.l	(v_fg_scroll_flags).w,d0-d1
00000856 48F8 0003 FF30             		movem.l	d0-d1,(v_fg_scroll_flags_dup).w
0000085C 6100 0000                  		bsr.w	LoadTilesAsYouMove
00000860 4EB9 0000 0000             		jsr	(AnimateLevelGfx).l
00000866 4EB9 0000 0000             		jsr	(HUD_Update).l
0000086C 6100 0000                  		bsr.w	sub_1642
00000870 4E75                       		rts	
00000872                            ; ===========================================================================
00000872                            
00000872                            VBla_0E:
00000872 6100 0000                  		bsr.w	sub_106E
00000876 5238 F628                  		addq.b	#1,($FFFFF628).w
0000087A 11FC 000E F62A             		move.b	#$E,(v_vbla_routine).w
00000880 4E75                       		rts	
00000882                            ; ===========================================================================
00000882                            
00000882                            VBla_12:
00000882 6100 0000                  		bsr.w	sub_106E
00000886 3AB8 F624                  		move.w	(v_hbla_hreg).w,(a5)
0000088A 6000 0000                  		bra.w	sub_1642
0000088E                            ; ===========================================================================
0000088E                            
0000088E                            VBla_16:
0000088E 33FC 0100 00A1 1100        		stopZ80
00000896 0839 0000 00A1 1100 66F6   		waitZ80
000008A0 6100 0000                  		bsr.w	ReadJoypads
000008A4 4BF9 00C0 0004 2ABC 9400+  		writeCRAM	v_pal_dry,$80,0
000008C8 4BF9 00C0 0004 2ABC 9401+  		writeVRAM	v_spritetablebuffer,$280,vram_sprites
000008EC 4BF9 00C0 0004 2ABC 9401+  		writeVRAM	v_hscrolltablebuffer,$380,vram_hscroll
00000910 33FC 0000 00A1 1100        		startZ80
00000918 4A38 F767                  		tst.b	(f_sonframechg).w
0000091C 6700                       		beq.s	@nochg
0000091E 4BF9 00C0 0004 2ABC 9401+  		writeVRAM	v_sgfx_buffer,$2E0,vram_sonic
00000942 11FC 0000 F767             		move.b	#0,(f_sonframechg).w
00000948                            
00000948                            	@nochg:
00000948 4A78 F614                  		tst.w	(v_demolength).w
0000094C 6700 0000                  		beq.w	@end
00000950 5378 F614                  		subq.w	#1,(v_demolength).w
00000954                            
00000954                            	@end:
00000954 4E75                       		rts	
00000956                            
00000956                            ; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
00000956                            
00000956                            
00000956                            sub_106E:
00000956 33FC 0100 00A1 1100        		stopZ80
0000095E 0839 0000 00A1 1100 66F6   		waitZ80
00000968 6100 0000                  		bsr.w	ReadJoypads
0000096C 4A38 F64E                  		tst.b	(f_wtr_state).w ; is water above top of screen?
00000970 6600                       		bne.s	@waterabove	; if yes, branch
00000972 4BF9 00C0 0004 2ABC 9400+  		writeCRAM	v_pal_dry,$80,0
00000996 6000                       		bra.s	@waterbelow
00000998                            
00000998                            	@waterabove:
00000998 4BF9 00C0 0004 2ABC 9400+  		writeCRAM	v_pal_water,$80,0
000009BC                            
000009BC                            	@waterbelow:
000009BC 4BF9 00C0 0004 2ABC 9401+  		writeVRAM	v_spritetablebuffer,$280,vram_sprites
000009E0 4BF9 00C0 0004 2ABC 9401+  		writeVRAM	v_hscrolltablebuffer,$380,vram_hscroll
00000A04 33FC 0000 00A1 1100        		startZ80
00000A0C 4E75                       		rts	
00000A0E                            ; End of function sub_106E
00000A0E                            
00000A0E                            ; ---------------------------------------------------------------------------
00000A0E                            ; Horizontal interrupt
00000A0E                            ; ---------------------------------------------------------------------------
00000A0E                            
00000A0E                            ; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
00000A0E                            
00000A0E                            
00000A0E                            HBlank:
00000A0E 46FC 2700                  		disable_ints
00000A12 4A78 F644                  		tst.w	(f_hbla_pal).w	; is palette set to change?
00000A16 6700                       		beq.s	@nochg		; if not, branch
00000A18 31FC 0000 F644             		move.w	#0,(f_hbla_pal).w
00000A1E 48E7 00C0                  		movem.l	a0-a1,-(sp)
00000A22 43F9 00C0 0000             		lea	(vdp_data_port).l,a1
00000A28 41F8 FA80                  		lea	(v_pal_water).w,a0 ; get palette from RAM
00000A2C 237C C000 0000 0004        		move.l	#$C0000000,4(a1) ; set VDP to CRAM write
00000A34 2298                       		move.l	(a0)+,(a1)	; move palette to CRAM
00000A36 2298                       		move.l	(a0)+,(a1)
00000A38 2298                       		move.l	(a0)+,(a1)
00000A3A 2298                       		move.l	(a0)+,(a1)
00000A3C 2298                       		move.l	(a0)+,(a1)
00000A3E 2298                       		move.l	(a0)+,(a1)
00000A40 2298                       		move.l	(a0)+,(a1)
00000A42 2298                       		move.l	(a0)+,(a1)
00000A44 2298                       		move.l	(a0)+,(a1)
00000A46 2298                       		move.l	(a0)+,(a1)
00000A48 2298                       		move.l	(a0)+,(a1)
00000A4A 2298                       		move.l	(a0)+,(a1)
00000A4C 2298                       		move.l	(a0)+,(a1)
00000A4E 2298                       		move.l	(a0)+,(a1)
00000A50 2298                       		move.l	(a0)+,(a1)
00000A52 2298                       		move.l	(a0)+,(a1)
00000A54 2298                       		move.l	(a0)+,(a1)
00000A56 2298                       		move.l	(a0)+,(a1)
00000A58 2298                       		move.l	(a0)+,(a1)
00000A5A 2298                       		move.l	(a0)+,(a1)
00000A5C 2298                       		move.l	(a0)+,(a1)
00000A5E 2298                       		move.l	(a0)+,(a1)
00000A60 2298                       		move.l	(a0)+,(a1)
00000A62 2298                       		move.l	(a0)+,(a1)
00000A64 2298                       		move.l	(a0)+,(a1)
00000A66 2298                       		move.l	(a0)+,(a1)
00000A68 2298                       		move.l	(a0)+,(a1)
00000A6A 2298                       		move.l	(a0)+,(a1)
00000A6C 2298                       		move.l	(a0)+,(a1)
00000A6E 2298                       		move.l	(a0)+,(a1)
00000A70 2298                       		move.l	(a0)+,(a1)
00000A72 2298                       		move.l	(a0)+,(a1)
00000A74 337C 8ADF 0004             		move.w	#$8A00+223,4(a1) ; reset HBlank register
00000A7A 4CDF 0300                  		movem.l	(sp)+,a0-a1
00000A7E 4A38 F64F                  		tst.b	($FFFFF64F).w
00000A82 6600                       		bne.s	loc_119E
00000A84                            
00000A84                            	@nochg:
00000A84 4E73                       		rte	
00000A86                            ; ===========================================================================
00000A86                            
00000A86                            loc_119E:
00000A86 4238 F64F                  		clr.b	($FFFFF64F).w
00000A8A 48E7 FFFE                  		movem.l	d0-a6,-(sp)
00000A8E 6100 FBDC                  		bsr.w	Demo_Time
00000A92 4EB9 0000 0000             		jsr	(UpdateMusic).l
00000A98 4CDF 7FFF                  		movem.l	(sp)+,d0-a6
00000A9C 4E73                       		rte	
00000A9E                            ; End of function HBlank
00000A9E                            
00000A9E                            ; ---------------------------------------------------------------------------
00000A9E                            ; Subroutine to	initialise joypads
00000A9E                            ; ---------------------------------------------------------------------------
00000A9E                            
00000A9E                            ; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
00000A9E                            
00000A9E                            
00000A9E                            JoypadInit:
00000A9E 33FC 0100 00A1 1100        		stopZ80
00000AA6 0839 0000 00A1 1100 66F6   		waitZ80
00000AB0 7040                       		moveq	#$40,d0
00000AB2 13C0 00A1 0009             		move.b	d0,($A10009).l	; init port 1 (joypad 1)
00000AB8 13C0 00A1 000B             		move.b	d0,($A1000B).l	; init port 2 (joypad 2)
00000ABE 13C0 00A1 000D             		move.b	d0,($A1000D).l	; init port 3 (expansion/extra)
00000AC4 33FC 0000 00A1 1100        		startZ80
00000ACC 4E75                       		rts	
00000ACE                            ; End of function JoypadInit
00000ACE                            
00000ACE                            ; ---------------------------------------------------------------------------
00000ACE                            ; Subroutine to	read joypad input, and send it to the RAM
00000ACE                            ; ---------------------------------------------------------------------------
00000ACE                            ; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
00000ACE                            
00000ACE                            
00000ACE                            ReadJoypads:
00000ACE 41F8 F604                  		lea	(v_jpadhold1).w,a0 ; address where joypad states are written
00000AD2 43F9 00A1 0003             		lea	($A10003).l,a1	; first	joypad port
00000AD8 6100                       		bsr.s	@read		; do the first joypad
00000ADA 5449                       		addq.w	#2,a1		; do the second	joypad
00000ADC                            
00000ADC                            	@read:
00000ADC 12BC 0000                  		move.b	#0,(a1)
00000AE0 4E71                       		nop	
00000AE2 4E71                       		nop	
00000AE4 1011                       		move.b	(a1),d0
00000AE6 E508                       		lsl.b	#2,d0
00000AE8 0200 00C0                  		andi.b	#$C0,d0
00000AEC 12BC 0040                  		move.b	#$40,(a1)
00000AF0 4E71                       		nop	
00000AF2 4E71                       		nop	
00000AF4 1211                       		move.b	(a1),d1
00000AF6 0201 003F                  		andi.b	#$3F,d1
00000AFA 8001                       		or.b	d1,d0
00000AFC 4600                       		not.b	d0
00000AFE 1210                       		move.b	(a0),d1
00000B00 B101                       		eor.b	d0,d1
00000B02 10C0                       		move.b	d0,(a0)+
00000B04 C200                       		and.b	d0,d1
00000B06 10C1                       		move.b	d1,(a0)+
00000B08 4E75                       		rts	
00000B0A                            ; End of function ReadJoypads
00000B0A                            
00000B0A                            
00000B0A                            ; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
00000B0A                            
00000B0A                            
00000B0A                            VDPSetupGame:
00000B0A 41F9 00C0 0004             		lea	(vdp_control_port).l,a0
00000B10 43F9 00C0 0000             		lea	(vdp_data_port).l,a1
00000B16 45F9 0000 0000             		lea	(VDPSetupArray).l,a2
00000B1C 7E12                       		moveq	#$12,d7
00000B1E                            
00000B1E                            	@setreg:
00000B1E 309A                       		move.w	(a2)+,(a0)
00000B20 51CF FFFC                  		dbf	d7,@setreg	; set the VDP registers
00000B24                            
00000B24 3039 0000 0000             		move.w	(VDPSetupArray+2).l,d0
00000B2A 31C0 F60C                  		move.w	d0,(v_vdp_buffer1).w
00000B2E 31FC 8ADF F624             		move.w	#$8A00+223,(v_hbla_hreg).w	; H-INT every 224th scanline
00000B34 7000                       		moveq	#0,d0
00000B36 23FC C000 0000 00C0 0004   		move.l	#$C0000000,(vdp_control_port).l ; set VDP to CRAM write
00000B40 3E3C 003F                  		move.w	#$3F,d7
00000B44                            
00000B44                            	@clrCRAM:
00000B44 3280                       		move.w	d0,(a1)
00000B46 51CF FFFC                  		dbf	d7,@clrCRAM	; clear	the CRAM
00000B4A                            
00000B4A 42B8 F616                  		clr.l	(v_scrposy_vdp).w
00000B4E 42B8 F61A                  		clr.l	(v_scrposx_vdp).w
00000B52 2F01                       		move.l	d1,-(sp)
00000B54 4BF9 00C0 0004 3ABC 8F01+  		fillVRAM	0,$FFFF,0
00000B76                            
00000B76                            	@waitforDMA:
00000B76 3215                       		move.w	(a5),d1
00000B78 0801 0001                  		btst	#1,d1		; is DMA (fillVRAM) still running?
00000B7C 66F8                       		bne.s	@waitforDMA	; if yes, branch
00000B7E                            
00000B7E 3ABC 8F02                  		move.w	#$8F02,(a5)	; set VDP increment size
00000B82 221F                       		move.l	(sp)+,d1
00000B84 4E75                       		rts	
00000B86                            ; End of function VDPSetupGame
00000B86                            
00000B86                            ; ===========================================================================
00000B86 8004                       VDPSetupArray:	dc.w $8004		; 8-colour mode
00000B88 8134                       		dc.w $8134		; enable V.interrupts, enable DMA
00000B8A 8230                       		dc.w $8200+(vram_fg>>10) ; set foreground nametable address
00000B8C 8328                       		dc.w $8300+($A000>>10)	; set window nametable address
00000B8E 8407                       		dc.w $8400+(vram_bg>>13) ; set background nametable address
00000B90 857C                       		dc.w $8500+(vram_sprites>>9) ; set sprite table address
00000B92 8600                       		dc.w $8600		; unused
00000B94 8700                       		dc.w $8700		; set background colour (palette entry 0)
00000B96 8800                       		dc.w $8800		; unused
00000B98 8900                       		dc.w $8900		; unused
00000B9A 8A00                       		dc.w $8A00		; default H.interrupt register
00000B9C 8B00                       		dc.w $8B00		; full-screen vertical scrolling
00000B9E 8C81                       		dc.w $8C81		; 40-cell display mode
00000BA0 8D3F                       		dc.w $8D00+(vram_hscroll>>10) ; set background hscroll address
00000BA2 8E00                       		dc.w $8E00		; unused
00000BA4 8F02                       		dc.w $8F02		; set VDP increment size
00000BA6 9001                       		dc.w $9001		; 64-cell hscroll size
00000BA8 9100                       		dc.w $9100		; window horizontal position
00000BAA 9200                       		dc.w $9200		; window vertical position
00000BAC                            
00000BAC                            ; ---------------------------------------------------------------------------
00000BAC                            ; Subroutine to	clear the screen
00000BAC                            ; ---------------------------------------------------------------------------
00000BAC                            
00000BAC                            ; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
00000BAC                            
00000BAC                            
00000BAC                            ClearScreen:
00000BAC 4BF9 00C0 0004 3ABC 8F01+  		fillVRAM	0,$FFF,vram_fg ; clear foreground namespace
00000BCE                            
00000BCE                            	@wait1:
00000BCE 3215                       		move.w	(a5),d1
00000BD0 0801 0001                  		btst	#1,d1
00000BD4 66F8                       		bne.s	@wait1
00000BD6                            
00000BD6 3ABC 8F02                  		move.w	#$8F02,(a5)
00000BDA 4BF9 00C0 0004 3ABC 8F01+  		fillVRAM	0,$FFF,vram_bg ; clear background namespace
00000BFC                            
00000BFC                            	@wait2:
00000BFC 3215                       		move.w	(a5),d1
00000BFE 0801 0001                  		btst	#1,d1
00000C02 66F8                       		bne.s	@wait2
00000C04                            
00000C04 3ABC 8F02                  		move.w	#$8F02,(a5)
00000C08 42B8 F616                  		clr.l	(v_scrposy_vdp).w
00000C0C 42B8 F61A                  		clr.l	(v_scrposx_vdp).w
00000C10                            
00000C10 43F8 F800                  		lea	(v_spritetablebuffer).w,a1
00000C14 7000                       		moveq	#0,d0
00000C16 323C 00A0                  		move.w	#($280/4),d1	; This should be ($280/4)-1, leading to a slight bug (first bit of v_pal_water is cleared)
00000C1A                            
00000C1A                            	@clearsprites:
00000C1A 22C0                       		move.l	d0,(a1)+
00000C1C 51C9 FFFC                  		dbf	d1,@clearsprites ; clear sprite table (in RAM)
00000C20                            
00000C20 43F8 CC00                  		lea	(v_hscrolltablebuffer).w,a1
00000C24 7000                       		moveq	#0,d0
00000C26 323C 0100                  		move.w	#($400/4),d1	; This should be ($400/4)-1, leading to a slight bug (first bit of the Sonic object's RAM is cleared)
00000C2A                            
00000C2A                            	@clearhscroll:
00000C2A 22C0                       		move.l	d0,(a1)+
00000C2C 51C9 FFFC                  		dbf	d1,@clearhscroll ; clear hscroll table (in RAM)
00000C30 4E75                       		rts	
00000C32                            ; End of function ClearScreen
00000C32                            
00000C32                            ; ---------------------------------------------------------------------------
00000C32                            ; Subroutine to	load the sound driver
00000C32                            ; ---------------------------------------------------------------------------
00000C32                            
00000C32                            ; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||
00000C32                            
00000C32                            
00000C32                            SoundDriverLoad:
00000C32 4E71                       		nop	
00000C34 33FC 0100 00A1 1100        		stopZ80
00000C3C 33FC 0100 00A1 1200        		resetZ80
00000C44 41F9 0000 0000             		lea	(Kos_Z80).l,a0	; load sound driver
00000C4A 43F9 00A0 0000             		lea	(z80_ram).l,a1	; target Z80 RAM
00000C50 6100 0000                  		bsr.w	KosDec		; decompress
00000C54 33FC 0000 00A1 1200        		resetZ80a
00000C5C 4E71                       		nop	
00000C5E 4E71                       		nop	
00000C60 4E71                       		nop	
00000C62 4E71                       		nop	
00000C64 33FC 0100 00A1 1200        		resetZ80
00000C6C 33FC 0000 00A1 1100        		startZ80
00000C74 4E75                       		rts	
00000C76                            ; End of function SoundDriverLoad
00000C76                            ; End of function SoundDriverLoad
00000C76                            
00000C76                            ; ---------------------------------------------------------------
00000C76                            ; Error handling module
00000C76                            ; ---------------------------------------------------------------
00000C76                            
00000C76                            		include "_Includes/Error Handler/ErrorHandler.asm"
00000C76                            
00000C76                            ; ===============================================================
00000C76                            ; ---------------------------------------------------------------
00000C76                            ; Error handling and debugging modules
00000C76                            ; 2016-2017, Vladikcomper
00000C76                            ; ---------------------------------------------------------------
00000C76                            ; Error handler functions and calls
00000C76                            ; ---------------------------------------------------------------
00000C76                            
00000C76                            ; ---------------------------------------------------------------
00000C76                            ; Error handler control flags
00000C76                            ; ---------------------------------------------------------------
00000C76                            
00000C76                            ; Screen appearence flags
00000C76 =00000001                  _eh_address_error	equ	$01		; use for address and bus errors only (tells error handler to display additional "Address" field)
00000C76 =00000002                  _eh_show_sr_usp		equ	$02		; displays SR and USP registers content on error screen
00000C76                            
00000C76                            ; Advanced execution flags
00000C76                            ; WARNING! For experts only, DO NOT USES them unless you know what you're doing
00000C76 =00000020                  _eh_return			equ	$20
00000C76 =00000040                  _eh_enter_console	equ	$40
00000C76 =00000080                  _eh_align_offset	equ	$80
00000C76                            
00000C76                            ; ---------------------------------------------------------------
00000C76                            ; Errors vector table
00000C76                            ; ---------------------------------------------------------------
00000C76                            
00000C76                            ; Default screen configuration
00000C76 =00000000                  _eh_default			equ	0 ;_eh_show_sr_usp
00000C76                            
00000C76                            ; ---------------------------------------------------------------
00000C76                            
00000C76                            BusError:
00000C76 4EB9 0000 0000 4255 5320+  	__ErrorMessage "BUS ERROR", _eh_default|_eh_address_error
00000C88                            
00000C88                            AddressError:
00000C88 4EB9 0000 0000 4144 4452+  	__ErrorMessage "ADDRESS ERROR", _eh_default|_eh_address_error
00000C9E                            
00000C9E                            IllegalInstr:
00000C9E 4EB9 0000 0000 494C 4C45+  	__ErrorMessage "ILLEGAL INSTRUCTION", _eh_default
00000CBA                            
00000CBA                            ZeroDivide:
00000CBA 4EB9 0000 0000 5A45 524F+  	__ErrorMessage "ZERO DIVIDE", _eh_default
00000CCE                            
00000CCE                            ChkInstr:
00000CCE 4EB9 0000 0000 4348 4B20+  	__ErrorMessage "CHK INSTRUCTION", _eh_default
00000CE6                            
00000CE6                            TrapvInstr:
00000CE6 4EB9 0000 0000 5452 4150+  	__ErrorMessage "TRAPV INSTRUCTION", _eh_default
00000D00                            
00000D00                            PrivilegeViol:
00000D00 4EB9 0000 0000 5052 4956+  	__ErrorMessage "PRIVILEGE VIOLATION", _eh_default
00000D1C                            
00000D1C                            Trace:
00000D1C 4EB9 0000 0000 5452 4143+  	__ErrorMessage "TRACE", _eh_default
00000D2A                            
00000D2A                            Line1010Emu:
00000D2A 4EB9 0000 0000 4C49 4E45+  	__ErrorMessage "LINE 1010 EMULATOR", _eh_default
00000D44                            
00000D44                            Line1111Emu:
00000D44 4EB9 0000 0000 4C49 4E45+  	__ErrorMessage "LINE 1111 EMULATOR", _eh_default
00000D5E                            
00000D5E                            ErrorExcept:
00000D5E 4EB9 0000 0000 4552 524F+  	__ErrorMessage "ERROR EXCEPTION", _eh_default
00000D76                            
00000D76                            
00000D76                            
00000D76                            ; ---------------------------------------------------------------
00000D76                            ; Import error handler global functions
00000D76                            ; ---------------------------------------------------------------
00000D76                            
00000D76                            ErrorHandler.__global__error_initconsole equ ErrorHandler+$146
00000D76                            ErrorHandler.__global__errorhandler_setupvdp equ ErrorHandler+$234
00000D76                            ErrorHandler.__global__console_loadpalette equ ErrorHandler+$A1C
00000D76                            ErrorHandler.__global__console_setposasxy_stack equ ErrorHandler+$A58
00000D76                            ErrorHandler.__global__console_setposasxy equ ErrorHandler+$A5E
00000D76                            ErrorHandler.__global__console_getposasxy equ ErrorHandler+$A8A
00000D76                            ErrorHandler.__global__console_startnewline equ ErrorHandler+$AAC
00000D76                            ErrorHandler.__global__console_setbasepattern equ ErrorHandler+$AD4
00000D76                            ErrorHandler.__global__console_setwidth equ ErrorHandler+$AE8
00000D76                            ErrorHandler.__global__console_writeline_withpattern equ ErrorHandler+$AFE
00000D76                            ErrorHandler.__global__console_writeline equ ErrorHandler+$B00
00000D76                            ErrorHandler.__global__console_write equ ErrorHandler+$B04
00000D76                            ErrorHandler.__global__console_writeline_formatted equ ErrorHandler+$BB0
00000D76                            ErrorHandler.__global__console_write_formatted equ ErrorHandler+$BB4
00000D76                            
00000D76                            
00000D76                            ; ---------------------------------------------------------------
00000D76                            ; Error handler external functions (compiled only when used)
00000D76                            ; ---------------------------------------------------------------
00000D76                            
00000D76                            
00000D76                            
00000D76                            
00000D76                            
00000D76                            ; ---------------------------------------------------------------
00000D76                            ; Include error handler binary module
00000D76                            ; ---------------------------------------------------------------
00000D76                            
00000D76                            ErrorHandler:
00000D76                            	incbin	"_Includes/Error Handler/ErrorHandler.bin"
00001976                            
00001976                            ; ---------------------------------------------------------------
00001976                            ; WARNING!
00001976                            ;	DO NOT put any data from now on! DO NOT use ROM padding!
00001976                            ;	Symbol data should be appended here after ROM is compiled
00001976                            ;	by ConvSym utility, otherwise debugger modules won't be able
00001976                            ;	to resolve symbol names.
00001976                            ; ---------------------------------------------------------------
00001976                            ; ---------------------------------------------------------------
00001976                            
00001976                            ; end of 'ROM'
00001976                            EndOfROM:
